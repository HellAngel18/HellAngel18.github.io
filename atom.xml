<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>地狱天使&#39;s Blog</title>
  
  <subtitle>欢迎来到我的世界</subtitle>
  <link href="http://lixrangel.com/atom.xml" rel="self"/>
  
  <link href="http://lixrangel.com/"/>
  <updated>2026-01-18T11:03:00.109Z</updated>
  <id>http://lixrangel.com/</id>
  
  <author>
    <name>地狱天使</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM调优</title>
    <link href="http://lixrangel.com/2025/12/09/jvm-diao-you/"/>
    <id>http://lixrangel.com/2025/12/09/jvm-diao-you/</id>
    <published>2025-12-08T16:00:00.000Z</published>
    <updated>2026-01-18T11:03:00.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><h3 id="设置堆内存大小（-Xms和-Xmx）"><a href="#设置堆内存大小（-Xms和-Xmx）" class="headerlink" title="设置堆内存大小（-Xms和-Xmx）"></a>设置堆内存大小（-Xms和-Xmx）</h3><ul><li>推荐显式设置这两个参数，并且通常建议<strong>将他们设置为相同的值</strong>，以避免堆内存的动态调整带来的性能开销。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-Xms&lt;heap</span> <span class="string">size&gt;[unit]</span> <span class="comment">#设置JVM初始堆大小 </span></span><br><span class="line"><span class="string">-Xmx&lt;heap</span> <span class="string">size&gt;[unit]</span> <span class="comment">#设置JVM最大堆大小</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;heap size&gt;</code>是指定内存的具体数值；</li><li><code>[unit]</code>是指定内存的单位，如G(GB)、M(MB)、K(KB)。</li></ul><h3 id="设置新生代内存大小（Young-Generation）"><a href="#设置新生代内存大小（Young-Generation）" class="headerlink" title="设置新生代内存大小（Young Generation）"></a>设置新生代内存大小（Young Generation）</h3><p>调优策略：</p><blockquote><p>尽量让新创建的对象在新生代分配内存并被回收，因为 Minor GC 的成本通常远低于 Full GC。通过分析 GC 日志，判断新生代空间分配是否合理。如果大量新对象过早进入老年代（Promotion），可以适当通过 -Xmn 或 -XX:NewSize/-XX:MaxNewSize 调整新生代大小，目标是最大限度地减少对象直接进入老年代的情况。</p></blockquote><ol><li> 通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:NewSize=&lt;young</span> <span class="string">size&gt;[unit]</span> <span class="comment">#指定新生代初始大小</span></span><br><span class="line"><span class="string">-XX:MaxNewSize=&lt;young</span> <span class="string">size&gt;[unit]</span> <span class="comment">#设置新生代最大大小</span></span><br></pre></td></tr></table></figure></li><li>通过<code>-Xmn&lt;young size&gt;[unit]</code>指定<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-Xmn512m</span></span><br></pre></td></tr></table></figure></li><li>通过<code>-XX:NewRatio=&lt;int&gt;</code>参数来设置老年代与新生代（不含Survivor区）的内存大小比例。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:NewRatio=2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="设置永久代-元空间大小（PermGen-Metaspace）"><a href="#设置永久代-元空间大小（PermGen-Metaspace）" class="headerlink" title="设置永久代/元空间大小（PermGen/Metaspace）"></a>设置永久代/元空间大小（PermGen/Metaspace）</h3><p>从Java 8开始，如果我们没有指定Metaspace的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><ul><li>JDK1.8之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:PermSize=N</span> <span class="comment">#方法区(永久代)初始大小</span></span><br><span class="line"><span class="string">-XX:MaxPermSize=N</span> <span class="comment">#方法区(永久代)最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure></li><li>JDK1.8的时候，方法区（HotSpot的永久代）被彻底移除了，取而代之的是元空间，元空间使用的是本地内存。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:MetaspaceSize=N</span> <span class="comment">#首次触发Full GC的阈值</span></span><br><span class="line"><span class="string">-XX:MaxMetaspaceSize=N</span> <span class="comment">#设置Metaspace的最大大小</span></span><br></pre></td></tr></table></figure>注意：</li><li><code>XX:MetaspaceSize</code>并非初始容量：Metaspace 的初始容量并不是<code>-XX:MetaspaceSize</code>设置，无论<code>-XX:MetaspaceSize</code>配置什么值，对于 64 位 JVM，元空间的<font color="#ff0000">初始容量通常是一个固定的较小值</font>（Oracle 文档提到约 12MB 到 20MB 之间，实际观察约 20.8MB）。</li><li>扩容与 Full GC：当 Metaspace 的使用量增长并首次达到<code>-XX:MetaspaceSize</code>指定的阈值时，会触发一次 Full GC。在此之后，JVM 会动态调整这个触发 GC 的阈值。如果元空间继续增长，每次达到新的阈值需要扩容时，仍然可能触发 Full GC（具体行为与垃圾收集器和版本有关）。垃圾搜集器内部是根据变量<code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MetaspaceGC::initialize() &#123;</span><br><span class="line">  <span class="comment">// Set the high-water mark to MaxMetapaceSize during VM initialization since</span></span><br><span class="line">  <span class="comment">// we can&#x27;t do a GC during initialization.</span></span><br><span class="line">  _capacity_until_GC = MaxMetaspaceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>-XX:MaxMetaspaceSize</code>的重要性</strong>：如果不显式设置<code>-XX:MaxMetaspaceSize</code>，元空间的最大大小理论上受限于可用的本地内存。在极端情况下（如类加载器泄漏导致不断加载类），这确实可能耗尽大量本地内存。因此，强烈建议设置一个合理的<code>-XX:MaxMetaspaceSize</code>上限，以防止对系统造成影响。</li></ul><h3 id="垃圾回收器相关参数"><a href="#垃圾回收器相关参数" class="headerlink" title="垃圾回收器相关参数"></a>垃圾回收器相关参数</h3><ul><li>Serial GC（串行垃圾收集器）：单线程执行GC，使用于客户端模式或单核cpu环境。参数<code>-XX:+UseParallelGC</code>。</li><li>Parallel GC（并行垃圾收集器）：多线程执行新生代GC（Minor GC），以及可选的多线程老年代GC（Full GC，通过<code>-XX:+UseParallelOldGC</code>)。关注吞吐量，是JDK 8的默认GC。参数<code>-XX:+UseParallelGC</code>。</li><li>CMS GC：以获取最短回收停顿时间为目标，大部分GC阶段可与用户线程并发执行。适用于对响应时间要求高的引应用。在JDK 9中被标记为弃用，JDK14中被移除。参数：<code>-XX:+UseConcMarkSweepGC</code>。</li><li>G1 GC：JDK 9及之后版本的默认GC。将堆划分为多个region，兼顾吞吐量和停顿时间，试图在可预测的停顿时间内完成GC。参数：<code>-XX:+UseG1GC</code>。</li></ul><h3 id="GC日志记录"><a href="#GC日志记录" class="headerlink" title="GC日志记录"></a>GC日志记录</h3><p>在生产环境或进行GC问题排查时，务必开启GC日志记录。以下是一些推荐配置的GC日志参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 推荐的基础配置 ---</span></span><br><span class="line"><span class="comment"># 打印详细 GC 信息</span></span><br><span class="line"><span class="string">-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># 打印 GC 发生的时间戳 (相对于 JVM 启动时间)</span></span><br><span class="line"><span class="comment"># -XX:+PrintGCTimeStamps</span></span><br><span class="line"><span class="comment"># 打印 GC 发生的日期和时间 (更常用)</span></span><br><span class="line"><span class="string">-XX:+PrintGCDateStamps</span></span><br><span class="line"><span class="comment"># 指定 GC 日志文件的输出路径，%t 可以输出日期时间戳</span></span><br><span class="line"><span class="string">-Xloggc:/path/to/gc-%t.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 推荐的进阶配置 ---</span></span><br><span class="line"><span class="comment"># 打印对象年龄分布 (有助于判断对象晋升老年代的情况)</span></span><br><span class="line"><span class="string">-XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"># 在 GC 前后打印堆信息</span></span><br><span class="line"><span class="string">-XX:+PrintHeapAtGC</span></span><br><span class="line"><span class="comment"># 打印各种类型引用 (强/软/弱/虚) 的处理信息</span></span><br><span class="line"><span class="string">-XX:+PrintReferenceGC</span></span><br><span class="line"><span class="comment"># 打印应用暂停时间 (Stop-The-World, STW)</span></span><br><span class="line"><span class="string">-XX:+PrintGCApplicationStoppedTime</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- GC 日志文件滚动配置 ---</span></span><br><span class="line"><span class="comment"># 启用 GC 日志文件滚动</span></span><br><span class="line"><span class="string">-XX:+UseGCLogFileRotation</span></span><br><span class="line"><span class="comment"># 设置滚动日志文件的数量 (例如，保留最近 14 个)</span></span><br><span class="line"><span class="string">-XX:NumberOfGCLogFiles=14</span></span><br><span class="line"><span class="comment"># 设置每个日志文件的最大大小 (例如，50MB)</span></span><br><span class="line"><span class="string">-XX:GCLogFileSize=50M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 可选的辅助诊断配置 ---</span></span><br><span class="line"><span class="comment"># 打印安全点 (Safepoint) 统计信息 (有助于分析 STW 原因)</span></span><br><span class="line"><span class="comment"># -XX:+PrintSafepointStatistics</span></span><br><span class="line"><span class="comment"># -XX:PrintSafepointStatisticsCount=1</span></span><br></pre></td></tr></table></figure><h3 id="处理OOM"><a href="#处理OOM" class="headerlink" title="处理OOM"></a>处理OOM</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在发生 OOM 时生成堆转储文件</span></span><br><span class="line"><span class="string">-XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定堆转储文件的输出路径。&lt;pid&gt; 会被替换为进程 ID</span></span><br><span class="line"><span class="string">-XX:HeapDumpPath=/path/to/heapdump/java_pid&lt;pid&gt;.hprof</span></span><br><span class="line"><span class="comment"># 示例：-XX:HeapDumpPath=/data/dumps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 在发生 OOM 时执行指定的命令或脚本</span></span><br><span class="line"><span class="comment"># 例如，发送告警通知或尝试重启服务（需谨慎使用）</span></span><br><span class="line"><span class="string">-XX:OnOutOfMemoryError=&quot;&lt;command&gt;</span> <span class="string">&lt;args&gt;&quot;</span></span><br><span class="line"><span class="comment"># 示例：-XX:OnOutOfMemoryError=&quot;sh /path/to/notify.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 启用 GC 开销限制检查</span></span><br><span class="line"><span class="comment"># 如果 GC 时间占总时间比例过高（默认 98%）且回收效果甚微（默认小于 2% 堆内存），</span></span><br><span class="line"><span class="comment"># 会提前抛出 OOM，防止应用长时间卡死在 GC 中。</span></span><br><span class="line"><span class="string">-XX:+UseGCOverheadLimit</span></span><br></pre></td></tr></table></figure><h3 id="其他常用参数"><a href="#其他常用参数" class="headerlink" title="其他常用参数"></a>其他常用参数</h3><ul><li><code>server</code>: 明确启用 Server 模式的 HotSpot VM。（在 64 位 JVM 上通常是默认值）。</li><li><code>XX:+UseStringDeduplication</code>: (JDK 8u20+) 尝试识别并共享底层 <code>char[]</code> 数组相同的 String 对象，以减少内存占用。适用于存在大量重复字符串的场景。</li><li><code>XX:SurvivorRatio=&lt;ratio&gt;</code>: 设置 Eden 区与单个 Survivor 区的大小比例。例如 <code>XX:SurvivorRatio=8</code> 表示 Eden:Survivor = 8:1。</li><li><code>XX:MaxTenuringThreshold=&lt;threshold&gt;</code>: 设置对象从新生代晋升到老年代的最大年龄阈值（对象每经历一次 Minor GC 且存活，年龄加 1）。默认值通常是 15。</li><li><code>XX:+DisableExplicitGC</code>: 禁止代码中显式调用 <code>System.gc()</code>。推荐开启，避免人为触发不必要的 Full GC。</li><li><code>XX:+UseLargePages</code>: (需要操作系统支持) 尝试使用大内存页（如 2MB 而非 4KB），可能提升内存密集型应用的性能，但需谨慎测试。</li><li><code>XX:MinHeapFreeRatio=&lt;percent&gt; / -XX:MaxHeapFreeRatio=&lt;percent&gt;</code>: 控制 GC 后堆内存保持空闲的最小/最大百分比，用于动态调整堆大小（如果 <code>Xms</code> 和 <code>Xmx</code> 不相等）。通常建议将 <code>Xms</code> 和 <code>Xmx</code> 设为一致，避免调整开销。</li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><ol><li>堆内存配置：建议显示设置初始与最大堆内存（<code>-Xms</code>、<code>-Xmx</code>，通常设为一致）和新生代大小（<code>-Xmn</code>或<code>-XX:NewSize/-XX:MaxNewSize</code>）。</li><li>元空间管理（Java 8+）：强烈建议设置<code>-XX:MaxMetaspaceSize</code>以防止潜在的本地内存耗尽。</li><li>垃圾收集器选择与日志：不同GC算法有不同的适用场景，在生产和测试环境中开启详细的GC日志。</li><li>OOM故障排查：通过<code>-XX:+HeapDumpOnOutOfMemoryError</code>等参数在发生OOM时自动生成堆转储文件，以便进行后续的内存泄漏分析。</li></ol><h2 id="遇到了OOM如何排查？"><a href="#遇到了OOM如何排查？" class="headerlink" title="遇到了OOM如何排查？"></a>遇到了OOM如何排查？</h2><ol><li>确保线上配置了<code>-XX:+HeapDumpOnOutOfMemoryError</code>，OOM时自动生成Dump文件。</li><li>使用MAT（Memory Analyzer Tool）或VisualVM打开Dump文件。</li><li>看<strong>Dominator Tree（支配树）</strong>，找到<strong>占用内存最大的对象</strong>。<ol><li>如果是<strong>内存泄漏</strong>：看它的GC Roots引用链，定位是哪个静态变量或组件持有了它。</li><li>如果是<strong>内存溢出</strong>：分析这些对象是否是业务必须的。如果是，考虑扩容堆内存或优化业务逻辑（如分页查询）。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM参数设置&quot;&gt;&lt;a href=&quot;#JVM参数设置&quot; class=&quot;headerlink&quot; title=&quot;JVM参数设置&quot;&gt;&lt;/a&gt;JVM参数设置&lt;/h2&gt;&lt;h3 id=&quot;设置堆内存大小（-Xms和-Xmx）&quot;&gt;&lt;a href=&quot;#设置堆内存大小（-Xms和-X</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="JVM" scheme="http://lixrangel.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="http://lixrangel.com/2025/12/08/jvm-la-ji-hui-shou/"/>
    <id>http://lixrangel.com/2025/12/08/jvm-la-ji-hui-shou/</id>
    <published>2025-12-07T16:00:00.000Z</published>
    <updated>2026-01-18T11:04:21.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM怎么判断对象是否是垃圾对象？"><a href="#JVM怎么判断对象是否是垃圾对象？" class="headerlink" title="JVM怎么判断对象是否是垃圾对象？"></a>JVM怎么判断对象是否是垃圾对象？</h2><ul><li><strong>引用计数法</strong>：<ul><li>原理：为每个对象分配一个<font color="#ff0000">引用计数器</font>，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当<font color="#ff0000">计数器为0</font>时，表示对象不再被任何变量引用，可以被回收。</li><li>缺点：不能解决<font color="#ff0000">循环引用</font>的问题，即<font color="#ff0000">两个对象相互引用</font>，但<font color="#ff0000">不再被其他任何对象引用</font>，这时引用计数器不会为0，导致对象无法被回收。</li></ul></li><li><strong>可达性分析算法</strong>：<ul><li>原理：扫描堆中的对象，以<font color="#ff0000">GC Roots对象为起点向下搜索</font>，节点所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，证明此对象是不可用的，则表示可以回收。</li></ul></li></ul><h3 id="追问：哪些对象是GC-Roots对象？——两栈两区"><a href="#追问：哪些对象是GC-Roots对象？——两栈两区" class="headerlink" title="追问：哪些对象是GC Roots对象？——两栈两区"></a>追问：哪些对象是GC Roots对象？——两栈两区</h3><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>本地方法栈（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><h2 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h2><ul><li><strong>标记-清除算法</strong>：分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有不需要回收的对象，在标记完成后统一回收所有没有被标记的对象。<ul><li>缺点：<ul><li>标记和清除的过程<font color="#ff0000">效率都不高</font>；</li><li>清除结束后会<font color="#ff0000">造成大量的碎片空间</font>。有可能会导致在申请大块内存的时候因为没有足够的连续空间导致再次出现GC。<br><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></li></ul></li></ul></li><li><strong>复制算法</strong>：复制算法是为了解决碎片空间的问题。原理是<font color="#ff0000">将内存分为两块</font>，每次申请时都是用其中的一块，当内存不够时，将<font color="#ff0000">这一块的内存中所有存活的复制到另一块上</font>。（每当遇到一个存活对象，就复制到另一块内存中）然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题，<font color="#ff0000">适合对象存活率较小</font>的情况（新生代）。<ul><li>缺点：<ul><li>可用内存变小，每次在申请内存时，都<font color="#ff0000">只能使用一半的内存空间</font>。内存利用率不足；</li><li>不适合老年代，如果存活对象的数量比较大，<font color="#ff0000">复制性能会变得很差</font>。<br><img src="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></li></ul></li></ul></li><li><strong>标记-整理算法</strong>：标记-整理算法的“标记”过程与标记-清除算法一致，但标记之后不会直接清理，而是<font color="#ff0000">将所有存活对象都移到内存的一端</font>。移动结束后直接清理掉端边界以外的内存。<font color="#ff0000">适合老年代</font>这种垃圾回收频率不是很高的场景。<br><img src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></li></ul><h2 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h2><table><thead><tr><th align="center">垃圾收集器</th><th align="center">类型</th><th align="center">作用域</th><th align="center">使用算法</th><th align="center">特点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行回收</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">适用于单核cpu环境下的Client模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行回收</td><td align="center">老年代</td><td align="center">标记-整理算法</td><td align="center">响应速度优先</td><td align="center">适用于单核cpu环境下的Client模式</td></tr><tr><td align="center">ParNew</td><td align="center">并行回收</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多核cpu环境下Server模式下与CMS配合使用</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行回收</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算，而交互少的场景</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行回收</td><td align="center">老年代</td><td align="center">标记-整理算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算，而交互少的场景</td></tr><tr><td align="center">CMS（Concurrent Mark Sweep）</td><td align="center">并发回收</td><td align="center">老年代</td><td align="center">标记-清除算法</td><td align="center">响应速度优先</td><td align="center">适用于B/S业务，也就是交互多的场景。</td></tr><tr><td align="center">G1（Garbage-First）</td><td align="center">并发，并行回收</td><td align="center">新生代&amp;老年代（整堆收集器）</td><td align="center">整体上：标记-整理算法；局部：复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端的应用</td></tr></tbody></table><ul><li><strong>Seria收集器（复制算法）</strong>：新生代单线程回收器，其他线程会阻塞，优点是简单高效；</li><li><strong>Serial Old收集器（标记-整理算法）</strong>：老年代单线程回收器，<font color="#ff0000">Serial回收器老年代版本</font>。<br><img src="Serial&Serial_Old%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="Serial&amp;Serial Old回收器"></li><li><strong>ParNew回收器（复制算法）</strong>：新生代并行回收器，实际上是<font color="#ff0000">Serial回收器的多线程版本</font>，目标是缩短垃圾收集时的单次停顿时间，在多核cpu环境下有比Serial更好的表现。<br><img src="ParNew%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="ParNew回收器"></li><li><strong>Parallel Scavenge收集器（复制算法）</strong>：新生代并行回收器，追求高吞吐量，高效利用cpu。适合后台应用对交互响应要求不高的场景。</li><li><strong>Parallel Old收集器（标记-整理算法）</strong>：老年代并行回收器，吞吐量优先，Parallel Scavenge回收器的老年代版本。<br><img src="Parallel_Scavenge&Parallel_Old%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="Parallel Scavenge&amp;Parallel Old回收器"></li><li><strong>CMS收集器（标记-清除算法）</strong>：老年代并行回收器，以<font color="#ff0000">获取最短回收停顿时间</font>为目标。具有高并发、低停顿的特点，追求最短GC回收停顿时间。<ul><li><font color="#0070c0">初始标记</font>：短暂停顿，标记直接与root相连的对象；</li><li><font color="#0070c0">并发标记</font>：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象，因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。</li><li><font color="#0070c0">重新标记</font>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间长，远远比并发标记阶段的时间短。</li><li><font color="#0070c0">并发清除</font>：开启用户线程，同时GC线程开始对未标记的区域做清扫。<br><img src="CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></li></ul></li><li><strong>G1收集器（标记-整理算法）</strong>：Java堆并行回收器，不会产生内存碎片。G1回收的范围是<font color="#ff0000">整个Java堆</font>（包括新生代、老年代）。<ul><li><font color="#0070c0">初始标记</font>：短暂停顿，标记从GC Roots可直接引用的对象，即标记所有直接可达的活跃对象。</li><li><font color="#0070c0">并发标记</font>：与应用并发运行，标记所有可达对象。</li><li><font color="#0070c0">最终标记</font>：短暂停顿，处理并发标记阶段结束后残留的少量未处理的引用变更。</li><li><font color="#0070c0">筛选回收</font>：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这个阶段包含一个或多个停顿，取决于回收的复杂度。<br><img src="G1%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="G1回收器"></li></ul></li></ul><h2 id="垃圾回收器CMS和G1的区别？"><a href="#垃圾回收器CMS和G1的区别？" class="headerlink" title="垃圾回收器CMS和G1的区别？"></a>垃圾回收器CMS和G1的区别？</h2><ul><li><strong>使用的范围不一样</strong>：<ul><li>CMS收集器是<font color="#ff0000">老年代的收集器</font>，可以配合新生代的Serial和ParNew收集器一起使用。</li><li>G1收集器收集范围是<font color="#ff0000">老年代和新生代</font>，不需要结合其他收集器使用。</li></ul></li><li><strong>STW的时间</strong>：<ul><li>CMS收集器是以<font color="#ff0000">最小的停顿时间为目标</font>的收集器。</li><li>G1收集器可以<font color="#ff0000">预测垃圾回收的停顿时间</font>。</li></ul></li><li><strong>垃圾碎片</strong>：<ul><li>CMS收集器使用<font color="#ff0000">“标记-清除”算法</font>进行垃圾回收，容易产生内存碎片。</li><li>G1收集器使用的是<font color="#ff0000">“标记-整理”算法</font>，进行了空间整合，没有内存空间碎片。</li></ul></li><li><strong>垃圾回收的过程不一样</strong></li></ul><h2 id="什么情况下使用CMS，什么情况使用G1？"><a href="#什么情况下使用CMS，什么情况使用G1？" class="headerlink" title="什么情况下使用CMS，什么情况使用G1？"></a>什么情况下使用CMS，什么情况使用G1？</h2><ul><li>CMS适用场景：<ul><li><strong>低延迟需求</strong>：适用于对停顿时间要求敏感的应用程序。</li><li><strong>老年代收集</strong>：主要针对老年代的垃圾回收。</li><li><strong>碎片化管理</strong>：容易出现内存碎片，可能需要定期Full GC来压缩内存空间。</li></ul></li><li>G1适用场景：<ul><li><strong>大堆内存</strong>：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。</li><li><strong>对内存碎片敏感</strong>：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。</li><li><strong>比较平衡的性能</strong>：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。</li></ul></li></ul><h2 id="G1回收器的特色是什么？"><a href="#G1回收器的特色是什么？" class="headerlink" title="G1回收器的特色是什么？"></a>G1回收器的特色是什么？</h2><ul><li>G1的特点：<ul><li>引入分区的思路，<strong>弱化了分代的概念</strong>；</li></ul></li><li>G1相比较CMS的改进：<ul><li><strong>算法</strong>：G1基于标记-整理算法，<font color="#ff0000">不会产生空间碎片</font>，在分配大对象时，不会因为无法得到连续的空间而<font color="#ff0000">提前触发一次Full GC</font>；</li><li><strong>停顿时间可控</strong>：G1可以通过设置<font color="#ff0000">预期停顿时间</font>来控制垃圾收集时间避免应用雪崩现象。</li><li><strong>并行与并发</strong>：G1能更充分的利用cpu多核环境下的硬件优势，来<font color="#ff0000">缩短STW的停顿时间</font>。</li></ul></li></ul><h2 id="minorGC、majorGC、fullGC的区别？"><a href="#minorGC、majorGC、fullGC的区别？" class="headerlink" title="minorGC、majorGC、fullGC的区别？"></a>minorGC、majorGC、fullGC的区别？</h2><ul><li><strong>minorGC（YoungGC）</strong><ul><li><strong>作用范围</strong>：<font color="#ff0000">只针对新生代进行回收</font>，包括Eden区和Survivor区；</li><li><strong>触发条件</strong>：当<font color="#ff0000">Eden区空间不足</font>时，JVM会触发一次minorGC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代。</li><li><strong>特点</strong>：通常发生的非常频繁，因为新生代中对象生命周期短，回收效率高，暂停时间相对较短。</li></ul></li><li><strong>majorGC</strong><ul><li><strong>作用范围</strong>：主要针对<font color="#ff0000">老年代进行回收</font>，但不一定只回收老年代；</li><li><strong>触发条件</strong>：当<font color="#ff0000">老年代空间不足</font>时，或者系统检测到<font color="#ff0000">新生代对象晋升到老年代的速度过快</font>，可能会触发majorGC。</li><li><strong>特点</strong>：相比minorGC，majorGC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高，需要花费更多开销去整理。</li></ul></li><li><strong>FullGC</strong><ul><li><strong>作用范围</strong>：对<font color="#ff0000">整个堆内存进行回收</font>。</li><li><strong>触发条件</strong>：<ul><li>直接调用<code>system.gc()</code>或<code>Runtime.getRuntime.gc()</code>方法时，虽然不能保证立即执行，但JVM会尝试执行FullGC。</li><li>minorGC时，如果<font color="#ff0000">存活的对象无法全部放入老年代</font>，或者老年代空间不足以容纳存活的对象，则会触发FullGC，对整个堆内存进行回收。</li><li>当<font color="#ff0000">永久代或者元空间空间不足</font>时。</li></ul></li><li><strong>特点</strong>：FullGC是最昂贵的操作，因为它需要停止所有的工作线程，遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少FullGC的触发。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM怎么判断对象是否是垃圾对象？&quot;&gt;&lt;a href=&quot;#JVM怎么判断对象是否是垃圾对象？&quot; class=&quot;headerlink&quot; title=&quot;JVM怎么判断对象是否是垃圾对象？&quot;&gt;&lt;/a&gt;JVM怎么判断对象是否是垃圾对象？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="JVM" scheme="http://lixrangel.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域&amp;类加载</title>
    <link href="http://lixrangel.com/2025/12/07/java-nei-cun-qu-yu-lei-jia-zai/"/>
    <id>http://lixrangel.com/2025/12/07/java-nei-cun-qu-yu-lei-jia-zai/</id>
    <published>2025-12-06T16:00:00.000Z</published>
    <updated>2026-01-18T10:56:27.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存区域-运行时数据区域"><a href="#Java内存区域-运行时数据区域" class="headerlink" title="Java内存区域/运行时数据区域"></a>Java内存区域/运行时数据区域</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><img src="JDK1.7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="JDK1.7内存区域"></p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p><img src="JDK1.8%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="JDK1.8内存区域"></p><ul><li><strong>线程私有区域</strong>：随线程创建而创建，随线程销毁而销毁，不需要垃圾回收。<ul><li><strong>程序计数器</strong>：用于存储当前<font color="#ff0000">线程正在执行的Java方法的JVM指令地址</font>。程序计数器是<font color="#ff0000">唯一一个不会出现OutOfMemoryError的内存区域</font>，生命周期与线程相同。</li><li><strong>Java虚拟机栈</strong>：每个线程有自己独立的Java虚拟机栈，生命周期与线程相同。<font color="#ff0000">每个方法在执行时都会创建一个栈帧</font>，用于存储局部变量表、操作数栈、动态链接、方法返回地址等。可能会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。<ul><li><code>StackOverflowError</code>：如果<font color="#ff0000">栈的内存大小不允许动态扩展</font>，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverflowError错误。</li><li><code>OutOfMemoryError</code>：如果<font color="#ff0000">栈的内存大小可以动态扩展</font>，那么当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul></li><li><strong>本地方法栈</strong>：与Java虚拟机栈类似，主要为<font color="#ff0000">虚拟机使用到的native方法</font>服务。本地方法执行时也会创建栈帧，同样可能出现<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</li></ul></li><li><strong>线程共享区域</strong>：是所有线程共用的，是垃圾回收的主要战场。<ul><li><strong>Java堆</strong>：JVM中最大的一块内存区域，几乎<font color="#ff0000">所有的对象实例和数组都在这里分配</font>。从垃圾回收角度，堆被划分为<font color="#ff0000">新生代和老年代</font>，新生代又分为Eden区和两个Survive区，如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出<code>OutOfMemoryError</code>异常。</li><li><strong>方法区（元空间）</strong>：用于存储已经<font color="#ff0000">被虚拟机加载的类信息、常量、静态变量</font>等数据。虽然方法区被描述为堆的逻辑部分，但有”非堆“的别名。<ul><li>JDK1.8之前，HotSpot虚拟机用<font color="#ff0000">“永久代”来实现方法区</font>。</li><li>JDK1.8及以后，永久代被移除，取而代之的是“<font color="#ff0000">元空间</font>”，它直接使用本地内存，不再受JVM堆大小的限制，只受本机物理内存限制。</li></ul></li></ul></li></ul><h2 id="创建对象的过程？"><a href="#创建对象的过程？" class="headerlink" title="创建对象的过程？"></a>创建对象的过程？</h2><p><img src="Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Java对象创建过程"></p><ol><li><strong>类加载检查</strong>：虚拟机遇到一条new指令时，首先去检查这个指令的参数（即类名）是否能够<font color="#ff0000">在常量池中定位到一个类的符号引用</font>，并且检查这个类是否已被加载、解析和初始化过。如果没有，就必须先执行相应的类加载过程。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定。<ol><li><font color="#0070c0">分配方式</font>：<ol><li><font color="#00b050">指针碰撞</font>：适用于<font color="#ff0000">堆内存没有内存碎片</font>的情况下。用过的内存全部整合到一边，没有用过的内存放在另一边，中间<font color="#ff0000">有一个分界指针</font>，只需要向着没用过的内存方向将该指针移动对象内存大小即可。</li><li><font color="#00b050">空闲列表</font>：适用于<font color="#ff0000">堆内存有内存碎片</font>的情况下。虚拟机会<font color="#ff0000">维护一个列表</font>，记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录。</li></ol></li><li><font color="#0070c0">内存分配并发问题</font>：<ol><li><font color="#ff0000">优先使用TLAB（本地线程分配缓冲）进行分配</font>，TLAB是在Eden区为每个线程预先分配的一小块私有内存；</li><li>如果TLAB用完了，才会在堆上使用<font color="#ff0000">CAS+失败重试</font>的机制进行原子分配。</li></ol></li></ol></li><li><strong>初始化零值</strong>：内存分配完成之后，虚拟机需要将分配到的内存空间都<font color="#ff0000">初始化为零值（不包括对象头）</font>。这一步保证了对象的实例字段在Java代码中可以不赋初值就直接使用。</li><li><strong>设置对象头</strong>：包括<font color="#ff0000">mark word</font>（存储哈希码、GC分代年龄、锁状态标志等）、<font color="#ff0000">Class Pointer</font>（类型指针，指向该对象的类元数据，确定它是哪个类的实例）。</li><li><strong>执行init方法</strong>：从JVM视角看对象已经创建好了，但从Java程序视角看，对象才刚刚开始。虚拟机<font color="#ff0000">执行init方法</font>，即按照程序员的意愿进行初始化（执行构造函数、成员变量赋值和构造代码块）。</li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><ul><li><strong>加载</strong>：通过<font color="#ff0000">类的全限定名</font>（包名+类名）获取<font color="#ff0000">二进制字节流</font>，然后将这个字节流所代表的静态存储结构转化为<font color="#ff0000">方法区的运行时数据结构</font>，并在堆中<font color="#ff0000">生成一个代表该类的java.lang.Class对象</font>，作为访问入口。</li><li><strong>验证</strong>：<font color="#ff0000">检查文件格式</font>、<font color="#ff0000">元数据验证</font>、<font color="#ff0000">字节码验证</font>、<font color="#ff0000">符号引用验证</font>。确保Class文件的字节流包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</li><li><strong>准备</strong>：在方法区中为类的<font color="#ff0000">类变量（Static变量）分配内存</font>，并将其<font color="#ff0000">初始化为默认零值</font>。这时候只分配static变量，不包括实例变量。这里初始化的值只是零值，但是如果被final static修饰，那么在准备阶段就会直接赋值。</li><li><strong>解析</strong>：虚拟机将常量池中的<font color="#ff0000">符号引用</font>替换为<font color="#ff0000">直接引用</font>。</li><li><strong>初始化</strong>：<font color="#ff0000">执行类构造器clinit方法</font>。就是把刚刚准备阶段赋的零值，替换为在代码中<font color="#ff0000">显式赋值</font>的数据，并执行<font color="#ff0000">静态代码块</font>。</li></ul><h2 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h2><p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="类加载器"></p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：最顶层的加载器，是JVM自身的一部分。是由C++实现的，负责<font color="#ff0000">加载JAVA_HOME/lib目录下的核心类库</font>（比如rt.jar，里面包含java.lang.* 、java.util.* 等最基础的类）。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：Java语言实现的，继承自ClassLoader类。负责加载<font color="#ff0000">JAVA_HOME/lib/ext目录下的扩展类库</font>。扩展类加载器由启动类加载器加载。</li><li><strong>应用程序类加载器（Application Class Loader）</strong>：Java语言实现的，负责加载<font color="#ff0000">用户类路径（ClassPath）上的指定类库</font>，是我们自己编写的Java类的加载器。</li><li><strong>自定义类加载器</strong>：开发者可以根据需求定制类的加载方式。</li></ul><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><ul><li>类加载的核心原则：一个类加载器要加载类时，<strong>先让父加载器去尝试加载</strong>，只有父加载器加载不了，自己才会去加载。</li><li>核心作用：<ul><li><strong>保证类的唯一性和安全性</strong>：避免同一个类被不同加载器重复加载，确保核心类（如JDK的String、Integer）不会被篡改。</li><li><strong>实现类的复用</strong>：核心类只会被顶层加载器加载一次，所有子加载器都能共享这个类，减少内存消耗。</li></ul></li></ul><h2 id="双亲委派模型的作用"><a href="#双亲委派模型的作用" class="headerlink" title="双亲委派模型的作用"></a>双亲委派模型的作用</h2><ul><li><strong>保证类的唯一性</strong>：确保所有加载请求都会传递到启动类加载器，<font color="#ff0000">避免了不同类加载器重复加载相同类</font>的情况。保证了Java核心类库的统一性，也<font color="#ff0000">防止了用户自定义类覆盖核心类库</font>的可能。</li><li><strong>保证安全性</strong>：由于Java核心类库被启动类加载器加载，而<font color="#ff0000">启动类加载器只加载信任的类路径中的类</font>，这样可以防止不可信的类假冒核心类，增加了系统的安全性。</li><li><strong>支持隔离和层次划分</strong>：双亲委派模型支持<font color="#ff0000">不同层次的类加载器服务于不同的类加载需求</font>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次的划分保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程</strong>：大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，<font color="#ff0000">简化了类的加载过程</font>，提高了加载效率。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java内存区域-运行时数据区域&quot;&gt;&lt;a href=&quot;#Java内存区域-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域/运行时数据区域&quot;&gt;&lt;/a&gt;Java内存区域/运行时数据区域&lt;/h2&gt;&lt;h3 id=&quot;JDK1-7&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="JVM" scheme="http://lixrangel.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal &amp; 线程池</title>
    <link href="http://lixrangel.com/2025/12/04/threadlocal-xian-cheng-chi/"/>
    <id>http://lixrangel.com/2025/12/04/threadlocal-xian-cheng-chi/</id>
    <published>2025-12-03T16:00:00.000Z</published>
    <updated>2026-01-18T10:44:08.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal原理了解吗？"><a href="#ThreadLocal原理了解吗？" class="headerlink" title="ThreadLocal原理了解吗？"></a>ThreadLocal原理了解吗？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个Thread对象内部有一个私有成员变量<code>threadlocals</code>，是一个<code>ThreadLocalMap</code>（是ThreadLocal的静态内部类）对象。默认情况下这个变量为null，当调用<code>set()</code>方法时才会创建。</li><li>当调用<code>threadlocal.set(value)</code>时，ThreadLocal会<font color="#ff0000">先获取当前线程</font>，然后从该线程中<font color="#ff0000">获取它的ThreadLocalMap</font>。接着<font color="#ff0000">ThreadLocal以它自己为key</font>，<font color="#ff0000">将value存入当前线程的ThreadLocalMap中</font>。调用<code>threadlocal.get()</code>时，会获取当前线程的ThreadLocalMap，然后以ThreadLocal为key，查找对应的value并返回。<br><img src="ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ThreadLocal数据结构"></li></ul><h2 id="ThreadLocal内存泄漏是什么原因导致的？"><a href="#ThreadLocal内存泄漏是什么原因导致的？" class="headerlink" title="ThreadLocal内存泄漏是什么原因导致的？"></a>ThreadLocal内存泄漏是什么原因导致的？</h2><ul><li>根本原因：ThreadLocalMap中Entry的设计结构——它的<strong>key（ThreadLocal对象）是弱引用</strong>，而<strong>value是强引用</strong>。</li><li>具体过程：<ul><li>当一个<font color="#ff0000">ThreadLocal对象在外部的强引用消失</font>后，GC会根据<font color="#ff0000">Entry中的弱引用来回收它</font>。ThreadLocal对象被回收后，Entry中的key就变成了null。</li><li>但是，这个Entry对象本身以及它所强引用的value仍然被ThreadLocalMap强引用着。</li><li>如果这个线程是一个<font color="#ff0000">线程池中的复用线程</font>，它不会被销毁，它的ThreadLocalMap也就一直存在着。</li><li>这就导致了ThreadLocalMap中存在大量key=null的Entry，它们强引用着本应被回收的value对象，造成了内存泄漏。</li></ul></li><li>内存泄漏需要同时满足两个条件：<ul><li><font color="#ff0000">ThreadLocal实例不再被强引用</font>；</li><li>线程池复用线程，导致<font color="#ff0000">线程持续存活</font>，导致ThreadLocalMap长期存在。</li></ul></li><li>解决办法：在使用完ThreadLocal后，务必调用<code>remove()</code>方法。</li></ul><h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><ul><li>通过<code>ThreadPoolExecutor</code>构造函数直接创建<br><img src="ThreadPoolExecutor%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="ThreadPoolExecutor创建线程池"></li><li>通过<code>Executors</code>工具类创建<br><img src="Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="Executors工具类创建线程池.png"></li></ul><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><ul><li><code>FixedThreadPool</code>：固定线程数量的线程池，<strong>核心线程数和最大线程数是一样的</strong>。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则<strong>新的任务会被暂存在一个任务队列</strong>（阻塞队列LinkedBlockingQueue）中，待有线程空闲时，便处理在任务队列中的任务。</li><li><code>SingleThreadExecutor</code>：<strong>只有一个线程的线程池</strong>。若多于一个任务被提交到线程池，任务会被保存在一个任务队列（阻塞队列LinkedBlockingQueue）中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><code>CachedThreadPool</code>：<strong>可根据实际情况调整线程数量的线程池</strong>，允许创建的线程数量为Integer.MAX_VALUE。队列是SynchronousQueue，队列的容量为0，实际不存储任何任务，生产者将任务放入队列后会一直阻塞，直到有消费者线程来取走他。</li><li><code>ScheduledThreadPool</code>和<code>SingleThreadScheduledExecutor</code>：可以设置定期的执行任务，<strong>支持定期或周期性执行任务</strong>。使用的无界的延迟阻塞队列DelayedWorkQueue。</li></ul><h3 id="这些线程池的弊端"><a href="#这些线程池的弊端" class="headerlink" title="这些线程池的弊端"></a>这些线程池的弊端</h3><ol><li>允许创建的“队列”无界（堆内存溢出）：<code>FixedThreadPool</code>和<code>SingleThreadExecutor</code><ul><li>队列是用的LinkedBlockingQueue，并且没有指定队列容量。此时<strong>队列的默认容量是Integer.MAX_VALUE</strong>。如果任务提交的速度&gt;任务处理的速度，任务就会在队列中无限堆积。</li><li>后果：<strong>大量的任务对象占用堆内存，导致Java Heap Space OOM</strong>。</li></ul></li><li>允许创建的“线程数”无界（系统资源耗尽）：<code>CachedThreadPool</code>和<code>ScheduledThreadPool</code><ul><li>将最大线程数设置为了Integer.MAX_VALUE。CachedThreadPool使用的SynchronousQueue。意味着只要有新任务来了，且没有空闲线程，它就会创建一个新线程去处理。如果任务提交速度非常快，线程池会疯狂创建成千上万个线程。</li><li>后果：<ul><li><strong>CPU爆满</strong>：大量<font color="#ff0000">线程上下文切换</font>拖垮cpu；</li><li><strong>OOM</strong>：每个线程都需要<font color="#ff0000">分配栈内存</font>，创建过多线程会导致unable to create new native thread OOM。</li></ul></li></ul></li></ol><h2 id="线程池的常见参数有哪些？"><a href="#线程池的常见参数有哪些？" class="headerlink" title="线程池的常见参数有哪些？"></a>线程池的常见参数有哪些？</h2><ul><li><code>corePoolSize</code>：任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code>：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>keepAliveTime</code>：当线程池中的线程数量大于corePoolSize，即有非核心线程时，这些非核心线程空闲后不会立即销毁，而是会等待，直到<font color="#ff0000">等待的时间超过了keepAliveTime才会回收销毁</font>。</li><li><code>until</code>：keepAliveTime参数的时间单位。</li><li><code>workQueue</code>：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li><li><code>threadFactory</code>：线程工厂。executor创建新线程的时候会用到。</li><li><code>handler</code>：如果当时同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，会执行拒绝策略。<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0.png" alt="线程池参数"></li></ul><h2 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h2><ul><li><code>AbortPolicy</code>：抛出<code>RejectedExecutionException</code>来拒绝新任务的处理。任务会丢失。</li><li><code>CallerRunsPolicy</code>：直接<font color="#ff0000">在调用execute方法的线程中运行被拒绝的任务</font>，如果执行程序已经关闭，则会丢弃该任务。</li><li><code>DiscardPolicy</code>：不处理新任务，<font color="#ff0000">直接丢弃</font>。</li><li><code>DiscardOldestPolicy</code>：<font color="#ff0000">丢弃最早的未处理</font>的任务请求。</li></ul><h2 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h2><ul><li><strong>cpu密集型任务（N + 1）</strong>：这种任务消耗的主要是CPU资源，可以将线程数设置为N（CPU核心数）+1。比CPU核心数多出来一个线程就是<font color="#ff0000">为了防止线程偶发的缺页中断</font>，或者其他原因导致的<font color="#ff0000">任务暂停而带来的影响</font>。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来一个线程就可以充分利用CPU的空闲时间。</li><li><strong>I/O密集型任务（2N）</strong>：这种任务系统会用<font color="#ff0000">大部分的时间来处理I/O交互</font>，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可以将CPU交出给其他线程使用。因此在I/O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是2N。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocal原理了解吗？&quot;&gt;&lt;a href=&quot;#ThreadLocal原理了解吗？&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal原理了解吗？&quot;&gt;&lt;/a&gt;ThreadLocal原理了解吗？&lt;/h2&gt;&lt;figure class</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="http://lixrangel.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全</title>
    <link href="http://lixrangel.com/2025/12/03/xian-cheng-an-quan/"/>
    <id>http://lixrangel.com/2025/12/03/xian-cheng-an-quan/</id>
    <published>2025-12-02T16:00:00.000Z</published>
    <updated>2026-01-18T10:36:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java如何保证多线程安全？"><a href="#Java如何保证多线程安全？" class="headerlink" title="Java如何保证多线程安全？"></a>Java如何保证多线程安全？</h2><ul><li><strong>synchronized关键字</strong>：可以使用synchronized关键字来<font color="#ff0000">同步代码块或方法</font>，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字<font color="#ff0000">锁定对象的监视器</font>来实现的。</li><li><strong>Lock接口和ReentrantLock类</strong>：<code>java.util.concurrent.locks.Lock</code>接口提供了比synchronized更强大的锁机制，ReentrantLock是一个实现该接口的例子，提供了<font color="#ff0000">更灵活的锁管理和更高的性能</font>。</li><li><strong>volatile关键字</strong>：volatile关键字用于变量，确保所有线程<font color="#ff0000">看到的是该变量的最新值</font>，而不是可能存储在本地寄存器的副本。</li><li><strong>原子类</strong>：Java并发库（<code>Java.util.concurrent.atomic</code>）提供了原子类，如AtomicInteger、AtomicLong等，这些类<font color="#ff0000">提供了原子操作</font>，可以用于<font color="#ff0000">更新基本类型的变量</font>而无需额外的同步。</li><li><strong>线程局部变量</strong>：ThreadLocal类可以为<font color="#ff0000">每个线程提供独立的变量副本</font>，这样每个线程拥有自己的变量，消除了竞争条件。</li><li><strong>并发集合</strong>：使用<code>java.util.concurrent</code>包中的<font color="#ff0000">线程安全集合</font>，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。</li></ul><h2 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h2><ul><li><strong>公平锁</strong>：锁被释放之后，<font color="#ff0000">先申请的线程先得到锁</font>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li><strong>非公平锁</strong>：锁被释放之后，<font color="#ff0000">后申请的线程可能会先获取到锁</font>，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul><li><strong>乐观锁</strong>：乐观锁总是假设最好的情况，<font color="#ff0000">认为共享资源每次被访问时不会发生冲突</font>，线程可以不停地执行，无需加锁无需等待，只是<font color="#ff0000">在提交修改的时候去验证对应的数据是否被其他线程修改</font>了。乐观锁通常用于<font color="#ff0000">写比较少的情况</font>，这样可以避免频繁加锁影响性能。乐观锁住要针对的对象是<font color="#ff0000">单个共享变量</font>。CAS是乐观锁的核心思想。</li><li><strong>悲观锁</strong>：总是假设最坏的情况，<font color="#ff0000">认为共享资源每次被访问时都会发生冲突</font>，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源的时候就会阻塞直到锁被上一个持有者释放。悲观锁通常用于<font color="#ff0000">写比较多的情况</font>，这样可以避免频繁失败和重试影响性能。synchronized和ReentrantLock是悲观锁的典型实现。</li></ul><h2 id="CAS（CompareAndSwap，比较再交换）"><a href="#CAS（CompareAndSwap，比较再交换）" class="headerlink" title="CAS（CompareAndSwap，比较再交换）"></a>CAS（CompareAndSwap，比较再交换）</h2><ul><li>体现了一种<font color="#ff0000">乐观锁</font>的思想，在<font color="#ff0000">无锁的状态下保证操作数据的原子性</font>。</li><li>CAS操作包含三个核心的参数：<ul><li>V：要更新的内存地址</li><li>A：预期的旧值</li><li>B：要更新的新值</li></ul></li><li>执行CAS时，当且仅当内存地址V处的值等于预期旧值A时，才会原子地将V处的值改为新值B。如果V处的值不等于A，说明其他线程已经修改了它，此时CAS失败，不做任何操作。</li><li>在java中，CAS底层依赖<code>Unsafe</code>类的方法，调用的是<font color="#ff0000">cpu级别的原子指令</font>。<code>java.util.concurrent.atomic</code>包下的所有原子类都广泛使用了CAS技术。通常配合while(true)循环使用，<font color="#ff0000">失败后不断重试</font>（也就是<font color="#ff0000">自旋</font>）。</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><ul><li>ABA问题是CAS机制的一个漏洞。</li><li>CAS在操作时，只关心“预期值A“和”当前值“是否相等。但<strong>如果一个值从A变成了B，然后又变回了A</strong>，CAS检查时会发现值仍然是A，误认为它没有被修改过，于是执行了交换操作。但在某些业务场景下，A-&gt;B-&gt;A的过程是需要被感知的。</li><li>解决办法：在变量前面追加上版本号或时间戳。JDK1.5之后的<code>AtomicStampedReference</code>类就是用来解决ABA问题的，其中的<code>compareAndSet()</code>方法就是在比较时，<strong>不但会比较当前值，还会比较一个戳记（Stamp）</strong>，这个戳记就相当于版本号，只有当值和版本号都同时满足预期时，CAS才会成功。</li></ul><h2 id="Java有哪些常用的锁？"><a href="#Java有哪些常用的锁？" class="headerlink" title="Java有哪些常用的锁？"></a>Java有哪些常用的锁？</h2><h3 id="从“实现方式”分类"><a href="#从“实现方式”分类" class="headerlink" title="从“实现方式”分类"></a>从“实现方式”分类</h3><p>分为JVM层面的锁和JDK代码层面的锁</p><ul><li>synchronized<ul><li>来源：Java关键字，由JVM也就是Hotspot虚拟机实现。</li><li>特点：<ul><li>加锁和释放锁自动完成</li><li>是可重入锁</li><li>一旦阻塞等待，无法被中断</li><li>默认是非公平锁，不能改成公平</li><li>为了性能优化，JVM内部实现了偏向锁-&gt;轻量级锁-&gt;重量级锁的升级机制。</li></ul></li></ul></li><li>Lock接口及其实现<ul><li>来源：JDK的java.util.concurrent.locks包，基于Java代码（AQS）实现。</li><li>核心实现类：<ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li></ul></li><li>特点：<ul><li>必须调用lock()加锁，必须在finally中调用unlock()释放锁。</li><li>支持尝试获取锁、超时获取、响应中断。</li><li>默认非公平，但是可以构造为公平锁。</li></ul></li></ul></li></ul><h3 id="从“锁的特性”分类"><a href="#从“锁的特性”分类" class="headerlink" title="从“锁的特性”分类"></a>从“锁的特性”分类</h3><ol><li>悲观锁 vs 乐观锁</li><li>可重入锁 vs 不可重入锁</li><li>公平锁 vs 非公平锁</li><li>独占锁 vs 共享锁</li></ol><h2 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h2><h3 id="核心实现机制"><a href="#核心实现机制" class="headerlink" title="核心实现机制"></a>核心实现机制</h3><ul><li>synchronized底层是<strong>基于monitor</strong>来实现的。编译器会在同步的代码块的<strong>开始位置插入<code>monitorenter</code>指令</strong>，在<strong>结束为止插入<code>monitorexit</code>指令</strong>。monitor底层是依赖于操作系统的<font color="#ff0000">Mutex Lock（互斥锁</font>）来实现的。</li></ul><h3 id="monitor的工作原理"><a href="#monitor的工作原理" class="headerlink" title="monitor的工作原理"></a>monitor的工作原理</h3><ul><li>在加锁时，JVM会<strong>修改对象头里的mark work中的数据</strong>，让它指向一个重量级的monitor对象。</li><li>monitor内部有三个属性：<ul><li><strong>owner</strong>：指向当前持有该monitor锁的线程。如果为null，表示锁为被占用。</li><li><strong>entrylist</strong>：一个队列，存放所有处于阻塞状态、等待获取该锁的线程。</li><li><strong>waitset</strong>：一个集合，存放了所有调用了该对象wait()方法而处于等待状态的线程。</li></ul></li></ul><h3 id="锁的获取与释放流程"><a href="#锁的获取与释放流程" class="headerlink" title="锁的获取与释放流程"></a>锁的获取与释放流程</h3><ul><li><strong>抢锁过程</strong>：当一个线程执行到monitorenter指令时，它会尝试获取monitor的所有权，也就是尝试将owner设为自己<ul><li>如果monitor的计数器为0，或者owner本来就是自己，线程会成功拿到锁，并将计数器+1；</li><li>如果锁已经被别人持有了，当前线程就会被阻塞，并进入Entrylist中排队等待。</li></ul></li><li><strong>释放过程</strong>：当执行monitorexit时，monitor的计数器会-1<ul><li>如果减完之后不是0，说明是可重入锁，线程依然持有锁；</li><li>如果减完之后是0，说明锁完全释放，owner被设置为null。此时会从Entrylist中唤醒一个等待的线程来重新竞争锁。</li></ul></li></ul><h2 id="synchronized可重入锁是怎么实现的？"><a href="#synchronized可重入锁是怎么实现的？" class="headerlink" title="synchronized可重入锁是怎么实现的？"></a>synchronized可重入锁是怎么实现的？</h2><ul><li>synchronized底层是利用操作系统Mutex Lock实现的，每一个可重入锁都会关联一个线程ID和一个计数器。</li><li>当一个线程请求获取锁时，会去检查锁的状态：<ul><li>如果计数器为0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换为自己的线程ID。</li><li>如果计数器不为0，代表有线程在访问该对象。此时，如果线程ID是自己的线程ID：<ul><li>可重入锁：将计数器自增1，然后获取到该锁；</li><li>不可重入锁：进入阻塞队列等待。</li></ul></li></ul></li><li>在释放锁时：<ul><li>如果是可重入锁，每一个退出方法，会将计数器减1，直至计数器的值为0，最后释放该锁；</li><li>如果是不可重入锁，线程退出方法，直接就会释放该锁。</li></ul></li></ul><h2 id="synchronized锁升级的过程"><a href="#synchronized锁升级的过程" class="headerlink" title="synchronized锁升级的过程"></a>synchronized锁升级的过程</h2><ul><li>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。整个锁升级的过程，其实就是一个随着竞争加剧，锁的状态逐步升级的过程：从<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li><li>一共三个阶段：<ul><li><strong>偏向锁</strong>：当 JVM 启动 4 秒后（因为有 <code>-XX:BiasedLockingStartupDelay</code> 默认延迟），如果一个对象被创建，它默认是可偏向状态。<ul><li><strong>触发时机</strong>：当<font color="#ff0000">第一个线程访问同步块</font>时。</li><li><strong>核心操作</strong>：JVM不会加锁，而是通过<font color="#ff0000">CAS操作</font>将当前线程的ID记录在对象头的mark word中。</li><li><strong>优势</strong>：当这个线程再次进入同步块时，只需要对比mark word中的线程ID是不是自己。如果是，完全不需要CAS也不需要加锁，直接执行。</li></ul></li><li><strong>轻量级锁</strong>：一旦有第二个线程尝试获取该锁，JVM会撤销偏向锁，将其升级为轻量级锁。<ul><li><strong>触发时机</strong>：<font color="#ff0000">出现了轻微的竞争</font>，或者两个线程交替执行，没有发生同时抢占。</li><li><strong>核心操作</strong>：<ul><li>JVM会在<font color="#ff0000">当前线程的栈帧</font>中建立一个名为<font color="#ff0000">Lock Record</font>（锁记录）的空间。</li><li>然后尝试<font color="#ff0000">用CAS将对象头的mark word替换为指向Lock Record</font>的指针。</li></ul></li><li><strong>自旋</strong>：如果CAS失败，线程不会立刻被挂起，而是会<font color="#ff0000">进行自旋</font>，看看能不能等持有锁的线程把锁释放掉。</li></ul></li><li><strong>重量级锁</strong><ul><li><strong>触发时机</strong>：<ul><li><font color="#ff0000">自旋超过了阈值</font>；</li><li>等待队列里已经有一个线程在自旋了，<font color="#ff0000">又来了第三个线程</font>。</li></ul></li><li><strong>核心操作</strong>：<ul><li>锁标志位变为10，<font color="#ff0000">mark word指向堆中的monitor对象</font>。</li><li>此时，通过CAS抢不到锁的线程，不再自旋，而是直接调用操作系统的底层互斥锁将自己挂起，进入阻塞队列等待唤醒。</li></ul></li></ul></li></ul></li></ul><h2 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h2><ul><li><code>AQS(AbstractQueuedSynchronizer)</code>是抽象队列同步器，是<code>java.util.concurrent</code>包下构建锁和同步器的核心基础框架。</li><li>AQS的核心设计：<ul><li><strong>一个state状态</strong>：<ul><li>是一个<font color="#ff0000">volatile的int类型的变量</font>，代表共享资源的状态；比如在ReentrantLock中，state=0代表锁空闲，state=1代表被占用，state&gt;1代表可重入次数。</li><li>AQS使用<font color="#ff0000">CAS操作来原子地修改这个state值</font>；</li></ul></li><li><strong>CHL变体双向队列</strong>：<ul><li><strong>Node节点</strong>：每个<font color="#ff0000">被阻塞的线程都会被封装成一个Node节点放入队列</font>。Node里包含了线程本身、状态以及前驱和后继指针。</li><li><strong>结构</strong>：队列头通常代表当前持有锁的线程，后续节点则是等待的线程。</li></ul></li></ul></li><li>核心过程：<ul><li><strong>抢锁</strong>：线程进来<font color="#ff0000">先尝试用CAS修改state</font>。如果成功，就拿到了锁，设置当前线程为exclusiveOwnerThread。</li><li><strong>入队与阻塞</strong>：如果CAS失败，线程会被封装成Node加入队尾。加入后，它会检查前驱节点是不是 Head，如果是就有机会再试一次。如果还不行，就调用 <code>LockSupport.park()</code> 让线程进入阻塞状态（此时线程交出 CPU，不再空转）。</li><li><strong>唤醒</strong>：当持有锁的线程调用 release() 时，它会修改 state，并调用 <code>LockSupport.unpark()</code> 唤醒队列中 Head 节点的下一个节点（Next），让其重新尝试 CAS 抢锁。<br><img src="AQS%E7%BB%93%E6%9E%84.png" alt="AQS结构"></li></ul></li></ul><h2 id="ReentrantLock底层原理"><a href="#ReentrantLock底层原理" class="headerlink" title="ReentrantLock底层原理"></a>ReentrantLock底层原理</h2><p><img src="ReentrantLock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="ReentrantLock底层原理"></p><ul><li><code>ReentrantLock</code>里面有一个内部类<code>Sync</code>，<code>Sync</code>继承自AQS，添加锁和释放锁的大部分操作实际上都是在<code>Sync</code>中实现的。<code>Sync</code>有公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>两个子类。</li><li><code>ReentrantLock</code>的底层就是由AQS实现的：<ul><li><strong>状态变量（state）</strong>：AQS内部维护一个<code>volatile int state</code>变量，用于表示锁的计数器或同步状态。<ul><li><font color="#ff0000">state=0</font>：表示锁当前处于未被占用状态；</li><li><font color="#ff0000">state&gt;0</font>：表示锁被占用，state的值即为重入次数。</li></ul></li><li><strong>获取锁（lock()）</strong>：线程尝试使用CAS将state从0设置为1。<ul><li>成功：表示获取锁成功，<font color="#ff0000">将当前线程设置为锁的独占线程</font>，是通过AQS的<code>exclusiveOwnerThread</code>变量记录。</li><li>失败：判断是否是<font color="#ff0000">重入</font>或<font color="#ff0000">阻塞</font>。</li></ul></li><li><strong>锁的重入</strong>：如果发现当前线程就是锁的独占线程，则直接将state+1，实现锁的重入。</li><li><strong>锁的阻塞</strong>：如果获取锁失败，且不是重入，则将<font color="#ff0000">当前线程封装成一个Node节点，加入到AQS的CLH等待队列中</font>，并进入阻塞状态。</li><li>AQS 使用一个<strong>双向链表</strong>作为同步队列（也称 CLH 队列），用于管理所有未能成功获取锁的线程。<ul><li><strong>队列结构：</strong> 队列的头节点（<code>head</code>）表示当前持有锁的线程的 Node，后续节点是等待锁的线程。</li><li><strong>入队：</strong> 竞争失败的线程会被封装成 Node，通过 <strong>CAS 尾插法</strong>安全地加入队列末尾。</li><li><strong>唤醒机制：</strong> 当持有锁的线程释放锁时，会唤醒队列中的<font color="#ff0000">头节点的后继节点</font>，被唤醒的线程会再次尝试竞争锁。</li></ul></li><li>**锁的释放 (<code>unlock()</code>)**：锁的释放过程是递减 <code>state</code> 计数器。<ul><li><strong>递减状态：</strong> 每次调用 <code>unlock()</code>，都将 <code>state</code> 减 1。</li><li><strong>完全释放：</strong> 当 <code>state</code> 递减到 0 时，表示锁被<strong>彻底释放</strong>。</li><li><strong>唤醒后继：</strong> 锁释放后，当前线程会设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>，然后<strong>唤醒 CLH 队列中的下一个等待线程</strong>。</li></ul></li></ul></li></ul><h2 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h2><ul><li><strong>实现层面</strong>：<ul><li><code>synchronized</code>：是Java关键字，<font color="#ff0000">由JVM底层实现</font>。依赖于对象头mark word和操作系统的monitor监视器锁。</li><li><code>ReentrantLock</code>：是JUC包中的一个API类。完全是<font color="#ff0000">用Java实现的</font>，底层依赖AQS。</li></ul></li><li><strong>锁的释放</strong>：<ul><li><code>synchronized</code>：synchronized会<font color="#ff0000">自动加锁和释放锁</font>，当进入synchronized修饰的代码块后会自动加锁，当离开synchronized的代码块后会自动释放锁。</li><li><code>ReentrantLock</code>：<font color="#ff0000">必须手动释放锁</font>。必须在finally块中显式调用unlock()方法。如果忘记释放，将导致灾难性的死锁。</li></ul></li><li>ReentrantLock提供了synchronized不具备的几个高级功能：<ul><li><strong>公平性选择</strong>：<ul><li><code>synchronized</code>是<font color="#ff0000">非公平锁</font>；</li><li><code>ReentrantLock</code>默认为非公平锁，但可以通过构造函数<code>new ReentrantLock(true)</code>创建公平锁。公平锁会按照线程请求的顺序（FIFO）来分配锁，但性能开销更大。</li></ul></li><li><strong>可中断的锁获取：</strong><ul><li><code>synchronized</code> 获取锁是<font color="#ff0000">阻塞且不可中断</font>的。如果一个线程拿不到锁，它会一直死等。</li><li><code>ReentrantLock</code> 提供了 <code>lockInterruptibly()</code> 方法，<font color="#ff0000">允许线程在等待锁的过程中响应中断</font>，增加了灵活性，可以避免死锁。</li></ul></li><li><strong>可超时的锁获取/非阻塞获取：</strong><ul><li><code>synchronized</code> <font color="#ff0000">只能一直等待</font>。</li><li><code>ReentrantLock</code> 提供了 <code>tryLock()</code> 和 <code>tryLock(time, unit)</code> 方法：<ul><li><code>tryLock()</code>：立即尝试获取锁，成功返回 <code>true</code>，失败返回 <code>false</code>，<font color="#ff0000">不阻塞</font>。</li><li><code>tryLock(time, unit)</code>：在指定时间内<font color="#ff0000">可超时地尝试获取锁</font>，超时则放弃。</li></ul></li></ul></li><li><strong>线程等待/唤醒机制：</strong><ul><li><code>synchronized</code>：配合 <code>Object</code> 类的 <code>wait()</code> / <code>notify()</code> / <code>notifyAll()</code> 使用。它只提供一个条件队列，<code>notifyAll</code> 会唤醒所有等待的线程，效率较低。</li><li><code>ReentrantLock</code>：配合 <code>Condition</code> 接口使用。它可以通过 <code>newCondition()</code> 创建多个 <code>Condition</code> 对象，实现更精确的线程分组等待和唤醒，灵活性和效率远高于 <code>wait/notify</code>。</li></ul></li></ul></li></ul><h2 id="指令重排序（单例模式举例）"><a href="#指令重排序（单例模式举例）" class="headerlink" title="指令重排序（单例模式举例）"></a>指令重排序（单例模式举例）</h2><ul><li><p>在JMM的规范下，编译器和cpu为了性能，会进行<font color="#ff0000">指令重排序</font>。重排序在单线程下有<code>as-if-serial</code>语义保证结果正确，但在多线程下，就可能破坏代码的逻辑。比如经典的<strong>双重检查锁定（DCL）下单例模式失效</strong>，就是重排序导致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">//第一次检查，只有为空的时候才加锁 </span></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line"><span class="comment">//类对象加锁 </span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line"><span class="comment">// 第二次检查，为了线程安全</span></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">return</span> uniqueInstance; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uniqueInstance = new Singleton();这段代码其实是分为三步执行：</p><ol><li>为<code>uniqueInstance</code>分配内存空间；</li><li>初始化<code>uniqueInstance</code>；</li><li>将<code>uniqueInstance</code>指向分配的内存地址；</li></ol></li><li><p>但是由于JVM具有指令重排序的特性，执行顺序有可能会变成1-&gt;3-&gt;2。在多线程环境下，线程T1执行了1和3，此时T2调用<code>getUniqueInstance()</code> 后发现<code>uniqueInstance</code>不为空，因此返回<code>uniqueInstance</code>，但此时<code>uniqueInstance</code>还未被初始化。</p></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><strong>保证线程间的可见性</strong>：当一个线程修改了volatile修饰的变量，这个修改<font color="#ff0000">会立刻被强制写回主内存</font>。同时，当其他线程在读取这个变量时，会立即使本地的工作内存失效，<font color="#ff0000">强制从主内存重新读取</font>。这样就确保了所有线程看到的都是最新值。</li><li><strong>禁止进行指令重排序</strong>：用volatile修饰共享变量会在读、写共享变量时加入不同的内存屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果：<ul><li><font color="#245bdb">写-写（Write-Write）屏障</font>：在对volatile变量执行写操作前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</li><li><font color="#245bdb">读-读（Read-Read）屏障</font>：在对volatile变量执行读操作后，会插入一个读屏障。它确保了对volatile变量的读操作后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取的数据是最新的。</li><li><font color="#245bdb">写-读（Write-Read）屏障</font>：发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作都不会被重排序到volatile读之后，同时也确保了volatile读操作之后所有的内存操作都不会被重排序到volatile写之前。</li></ul></li><li>volatile<font color="#ff0000">只保证了可见性和有序性，不保证原子性</font>。比如i++这样的复合操作（也就是只能一个线程写，多个线程读）。</li></ul><h2 id="synchronized和volatile有什么区别？"><a href="#synchronized和volatile有什么区别？" class="headerlink" title="synchronized和volatile有什么区别？"></a>synchronized和volatile有什么区别？</h2><ul><li><strong>使用范围</strong>：<ul><li><code>volatile</code>只能<font color="#ff0000">修饰变量</font>；</li><li><code>synchronized</code>可以<font color="#ff0000">修饰方法或代码块</font>；</li></ul></li><li><strong>保持的特性</strong>：<ul><li><code>volatile</code>只能保证<font color="#ff0000">可见性和有序性</font>；</li><li><code>synchronized</code>可以保证可见性、有序性，还能<font color="#ff0000">保证原子性</font>；</li></ul></li><li><strong>是否阻塞</strong>：<ul><li><code>volatile</code>是<font color="#ff0000">非阻塞的</font>，不会引起线程上下文切换；</li><li><code>synchronized</code>是<font color="#ff0000">阻塞的</font>。如果一个线程获取不到锁，会进入阻塞状态，等待锁被释放，涉及线程上下文的切换。</li></ul></li><li><strong>性能</strong>：<ul><li><code>volatile</code>是<font color="#ff0000">轻量级同步机制</font>，性能开销小；</li><li><code>synchronized</code>是<font color="#ff0000">重量级锁</font>；</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java如何保证多线程安全？&quot;&gt;&lt;a href=&quot;#Java如何保证多线程安全？&quot; class=&quot;headerlink&quot; title=&quot;Java如何保证多线程安全？&quot;&gt;&lt;/a&gt;Java如何保证多线程安全？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;synchron</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="http://lixrangel.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="http://lixrangel.com/2025/12/02/xian-cheng-ji-chu/"/>
    <id>http://lixrangel.com/2025/12/02/xian-cheng-ji-chu/</id>
    <published>2025-12-01T16:00:00.000Z</published>
    <updated>2026-01-18T10:39:52.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><ul><li><strong>本质区别</strong>：进程是<font color="#ff0000">操作系统资源分配</font>的基本单位，而线程是<font color="#ff0000">任务调度和执行</font>的基本单位。</li><li><strong>在开销方面</strong>：每个进程有<font color="#ff0000">独立的代码和数据空间</font>，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程有自己<font color="#ff0000">独立的运行栈和程序计数器</font>，线程之间切换的开销小。</li><li><strong>稳定性方面</strong>：进程中某个线程崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li><li><strong>内存分配方面</strong>：进程是资源分配的基本单位，拥有独立的地址空间；而线程是cpu调度的基本单位，<font color="#ff0000">几乎不拥有系统资源</font>，只保留少量私有数据（PC、栈、寄存器），主要共享其所属进程的资源。</li></ul><h2 id="进程、线程、协程的区别是什么？"><a href="#进程、线程、协程的区别是什么？" class="headerlink" title="进程、线程、协程的区别是什么？"></a>进程、线程、协程的区别是什么？</h2><ul><li><strong>进程</strong>是操作系统中进行<font color="#ff0000">资源分配和调度的基本单位</font>，拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。<font color="#ff0000">进程间通信需要通过特定的机制</font>，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其<font color="#ff0000">稳定性和安全性相对较高</font>，但同时<font color="#ff0000">上下文切换的开销也大</font>，因为需要保存和恢复整个进程的状态。</li><li><strong>线程</strong>是进程内的一个执行单元，也是<font color="#ff0000">cpu调度和分派的基本单位</font>。与进程不同，线程共享进程的内存空间，包括堆和全局变量。<font color="#ff0000">线程之间通信更加高效</font>，因为它们可以直接读写共享内存。线程的<font color="#ff0000">上下文切换开销较小</font>，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此<font color="#ff0000">存在数据竞争和线程安全</font>的问题，需要通过同步和互斥机制来解决。</li><li><strong>协程</strong>是一种<font color="#ff0000"><strong>用户态</strong>的轻量级线程</font>，其调度完全由用户程序控制，而<font color="#ff0000">不需要内核的参与</font>。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的<font color="#ff0000">切换开销非常小</font>，因为只需要保存和恢复协程的上下文，而<font color="#ff0000">无需进行内核级的上下文切换</font>。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其<font color="#ff0000">编程模型更为复杂</font>。</li></ul><h2 id="线程间的同步方式有哪些？"><a href="#线程间的同步方式有哪些？" class="headerlink" title="线程间的同步方式有哪些？"></a>线程间的同步方式有哪些？</h2><ol><li><strong>互斥锁（Mutex）</strong>：采用<font color="#ff0000">互斥对象机制</font>，只有拥有互斥对象的线程才能访问公共资源。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如<font color="#ff0000">synchronized关键字和各种Lock都是这种机制</font>。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。<font color="#ff0000">读锁不互斥，写锁互斥</font>。大大提高读多写少的共享资源访问效率。</li><li><strong>信号量（Semaphore）</strong>：它允许同一时刻多个线程访问同一资源，但是需要控制<font color="#ff0000">同一时刻访问此资源的最大线程数量</font>。维护一个计数器，线程获取资源时计数器减1，释放时加1。</li><li><strong>屏障（Barrier）</strong>：屏障是一种<font color="#ff0000">同步原语</font>，用于<font color="#ff0000">等待多个线程到达某个点再一起继续执行</font>。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都达到屏障后，它们才会一起执行。</li><li><strong>事件（Event）</strong>：<font color="#ff0000">Wait()/notify()</font>，通过通知操作的方式来保持多线程同步。</li></ol><h2 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h2><ol><li><strong>继承Thread类</strong>：重写<code>run()</code>方法，不能再继承其他父类；</li><li><strong>实现Runnable接口</strong>：重写<code>run()</code>方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其<code>start()</code>方法启动线程；</li><li><strong>实现Callable接口</strong>：重写<code>call()</code>方法，<code>call()</code>方法可以有返回值并且可以抛出异常。将此对象包装进一个<code>FutureTask</code>，然后将<code>FutureTask</code>传入Thread构造器（Thread构造器只接收Runnable参数，而FutureTask实现了Runnable接口）；</li><li><strong>使用线程池创建</strong><h3 id="追问：Runnable和Callable有什么区别？"><a href="#追问：Runnable和Callable有什么区别？" class="headerlink" title="追问：Runnable和Callable有什么区别？"></a>追问：Runnable和Callable有什么区别？</h3></li><li><strong>Runnable接口</strong>run方法<font color="#ff0000">没有返回值</font>。<strong>Callable接口</strong>call方法<font color="#ff0000">有返回值</font>，是个泛型，和Future、FutureTask配合<font color="#ff0000">可以用来获取异步执行的结果</font>。</li><li><strong>Callable接口</strong>的call方法<font color="#ff0000">允许抛出异常</font>；而<strong>Runnable接口</strong>的run方法的<font color="#ff0000">异常只能在内部消化</font>，不能继续上抛。</li></ol><h2 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h2><ul><li><strong>创建状态（new）</strong>：进程<font color="#ff0000">正在被创建</font>，尚未到就绪状态。</li><li><strong>就绪状态（ready）</strong>：进程已处于准备运行状态，即进程<font color="#ff0000">获得了除了处理器之外的一切所需资源</font>，一旦得到处理器资源即可运行。</li><li><strong>运行状态（running）</strong>：进程正在处理器上运行。</li><li><strong>阻塞状态（waiting）</strong>：又称为等待状态，进程正在<font color="#ff0000">等待某一事件而暂停运行</font>如等待某些资源或者等待IO操作完成。即使cpu空闲，该进程也不能运行。</li><li><strong>结束状态（terminated）</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h2 id="线程包含哪些状态？状态之间如何切换？"><a href="#线程包含哪些状态？状态之间如何切换？" class="headerlink" title="线程包含哪些状态？状态之间如何切换？"></a>线程包含哪些状态？状态之间如何切换？</h2><ul><li><strong>新建（NEW）</strong>、<strong>可运行（RUNNABLE）</strong>、<strong>阻塞（BLOCKED）</strong>、<strong>等待(WAITING)<strong>、</strong>计时等待（TIMED_WAITING）</strong>、<strong>终止（TERMINATED）</strong></li><li><font color="#ff0000">创建线程对象</font>是<font color="#ff0000">新建状态</font>，但此时还没有调用start方法；</li><li><font color="#ff0000">调用了start()方法</font>转变为<font color="#ff0000">就绪状态</font>，等待调度。<font color="#ff0000">调度后</font>变为<font color="#ff0000">运行状态</font>；</li><li>线程获取到了cpu的执行权，<font color="#ff0000">执行结束</font>是<font color="#ff0000">终止状态</font>。</li><li>在可运行状态的过程中，如果没有获取cpu的执行权，可能会切换到其他状态：<ul><li>如果<font color="#ff0000">没有获取锁</font>（synchronized或lock）进入<font color="#ff0000">阻塞状态</font>，获得锁再切换为可运行状态；</li><li>如果线程<font color="#ff0000">调用了wait()方法</font>进入<font color="#ff0000">等待状态</font>，其他线程调用notify()唤醒后可切换为可运行状态；</li><li>如果线程<font color="#ff0000">调用了sleep(50)方法</font>，进入<font color="#ff0000">计时等待状态</font>，到时间后可切换为可运行状态。<br><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E5%88%87%E6%8D%A2.png" alt="线程状态及其切换"></li></ul></li></ul><h2 id="进程间通信方式有哪些？"><a href="#进程间通信方式有哪些？" class="headerlink" title="进程间通信方式有哪些？"></a>进程间通信方式有哪些？</h2><ol><li><strong>管道/匿名管道（Pipes）</strong>：用于具有<font color="#ff0000">亲缘关系的父子进程间</font>或者<font color="#ff0000">兄弟进程</font>之间的通信。通信的数据是<font color="#ff0000">无格式的字节流</font>并且<font color="#ff0000">大小受限</font>，<font color="#ff0000">通信的方式是单向的</font>。存在于内存中，进程结束，管道就消失了。</li><li><strong>有名管道（Named Pipes）</strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。有名管道需要在文件系统中创建一个类型为p的设备文件，那么毫无关系的进程就可以<font color="#ff0000">通过这个设备文件进行通信</font>。有名管道严格遵循先进先出。</li><li><strong>消息队列（Message Queuing）</strong>：存放在<font color="#ff0000">内核内存中的消息链表</font>，通过消息队列标识符识别。数据是<font color="#ff0000">有格式、结构化的数据</font>，消息体是用户自定义的数据类型。发送和接收方必须保持数据类型一致。默认遵循先进先出原则，但是也可以<font color="#ff0000">实现消息的随机查询</font>。<font color="#ff0000">生命周期独立于进程</font>，只有在内核重启或显式删除时，消息队列才会被真正删除。每次读写都需要<font color="#ff0000">经过用户态和内核态之间的数据拷贝过程</font>，因此通信速度不是最及时的。</li><li><strong>共享内存（Shared memory）</strong>：使得<font color="#ff0000">多个进程可以访问同一块内存空间</font>，不同进程可以及时看到对方进程中对共享内存中数据的更新。可以<font color="#ff0000">解决</font>消息队列通信中用户态和内核态之间数据<font color="#ff0000">拷贝过程带来的开销</font>。这种方式需要<font color="#ff0000">依靠某种同步操作</font>，如互斥锁和信号量等。但是多进程竞争同个共享资源会造成数据的错乱。</li><li><strong>信号量（Semaphore）</strong>：信号量是一个<font color="#ff0000">计数器</font>，用于多进程对共享数据的访问。这种通信方式主要用于<font color="#ff0000">解决共享内存的问题</font>。</li><li><strong>信号（Signal）</strong>：一种模拟硬件中断的机制，传递的信息量极少，主要<font color="#ff0000">用于通知进程某个事件的发生</font>。</li><li><strong>套接字（Socket）</strong>：此方法主要用于<font color="#ff0000">不同主机之间通过网络进行通信</font>。支持TCP/IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点。</li></ol><h2 id="线程间的通信方式有哪些？"><a href="#线程间的通信方式有哪些？" class="headerlink" title="线程间的通信方式有哪些？"></a>线程间的通信方式有哪些？</h2><ol><li><strong>共享变量</strong><ol><li><strong>volatile关键字</strong>。保证可见性；</li><li><strong>synchronized关键字</strong>。保证可见性和原子性。</li></ol></li><li><strong>等待/通知机制</strong><ol><li>**Object的wait() / notify()**。必须配合synchronized使用。</li><li>**Condition的await() / signal()**。必须配合ReentrantLock使用。</li></ol></li></ol><h2 id="Java中wait和sleep方法的不同？"><a href="#Java中wait和sleep方法的不同？" class="headerlink" title="Java中wait和sleep方法的不同？"></a>Java中wait和sleep方法的不同？</h2><ul><li><strong>方法归属不同</strong>：<ul><li>sleep(long)是<font color="#ff0000">Thread的静态方法</font>，可以在任何地方通过Thread.sleep()调用，无需依赖实例对象。</li><li>wait()、wait(long)都是<font color="#ff0000">Object的成员方法</font>，每个对象都有，<font color="#ff0000">必须通过对象实例来调用</font>。</li></ul></li><li><strong>锁释放的情况</strong>：<ul><li>Thread.sleep()在调用时，线程会暂停执行指定的时间，但是<font color="#ff0000">不会释放持有的对象锁</font>。</li><li>Object.wait()在调用时，线程<font color="#ff0000">会释放持有的对象锁</font>，进入等待状态，直到其他线程调用相同对象的notify()或notifyAll()方法唤醒他。</li></ul></li><li><strong>使用条件</strong>：<ul><li>sleep可以<font color="#ff0000">在任意位置调用</font>，无需事先获得锁。</li><li>wait必须在<font color="#ff0000">同步块或同步方法内调用</font>，即线程需持有该对象的锁，否则抛出异常。</li></ul></li><li><strong>醒来时机不同</strong>：<ul><li>执行sleep(long)和wait(long)的线程都会在<font color="#ff0000">等待相应毫秒后醒来</font></li><li>wait(long)和wait()还<font color="#ff0000">可以被notify唤醒</font>，wait如果<font color="#ff0000">不唤醒就会一直等下去</font>。</li><li>它们都可以被打断唤醒。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程和进程的区别？&quot;&gt;&lt;a href=&quot;#线程和进程的区别？&quot; class=&quot;headerlink&quot; title=&quot;线程和进程的区别？&quot;&gt;&lt;/a&gt;线程和进程的区别？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本质区别&lt;/strong&gt;：进程是&lt;font color</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="http://lixrangel.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap&amp;ConcurrentHashMap</title>
    <link href="http://lixrangel.com/2025/11/29/hashmap-concurrenthashmap/"/>
    <id>http://lixrangel.com/2025/11/29/hashmap-concurrenthashmap/</id>
    <published>2025-11-28T16:00:00.000Z</published>
    <updated>2026-01-18T10:52:23.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的底层实现？"><a href="#HashMap的底层实现？" class="headerlink" title="HashMap的底层实现？"></a>HashMap的底层实现？</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><ul><li><strong>数据结构</strong>：<font color="#ff0000">数组</font>+<font color="#ff0000">链表</font>结合在一起使用，也就是<font color="#ff0000">链表散列</font>。</li><li>获取key的hashcode，hashcode经过扰动函数（<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>）hashcode的高16位和低16位进行异或（这样处理是为了混合高位和低位，以此来加大低位的随机性）处理后得到哈希值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置。<ul><li>如果当前位置存在元素的话，就判断该元素与要存入元素的hash值（hash值的比较非常快）以及key（key比较很慢）是否相同，如果相同的话，直接覆盖；如果不相同的话就通过拉链法解决冲突。<br><img src="HashMap1.8%E4%BB%A5%E5%89%8D.png" alt="HashMap1.8以前"></li></ul></li></ul><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><ul><li><strong>数据结构</strong>：<font color="#ff0000">数组+链表+红黑树</font></li><li><strong>扩容</strong>：当链表长度大于阈值（默认为8），先判断数组长度是不是小于64，如果小于64，则先进行数组的扩容。</li><li><strong>链表-&gt;红黑树</strong>：当数组长度大于64时，将链表转化为红黑树。</li><li><strong>目的</strong>：减少搜索时间。链表的查询效率为O(n)，红黑树的查询效率为O(logn)。当链表较短时，O(n)和O(logn)的性能差异不明显。但当链表变长时，查询性能会显著下降。<br><img src="HashMap1.8%E4%BB%A5%E5%90%8E.png" alt="HashMap1.8以后.png"></li></ul><h2 id="为什么优先扩容而不是直接转化为红黑树？"><a href="#为什么优先扩容而不是直接转化为红黑树？" class="headerlink" title="为什么优先扩容而不是直接转化为红黑树？"></a>为什么优先扩容而不是直接转化为红黑树？</h2><ul><li>数组扩容能<strong>减少哈希冲突的发生概率</strong>，在多数情况下比直接转为红黑树更有效。</li><li>红黑树需要保持自平衡，<strong>维护成本较高</strong>。并且，过早引入红黑树反而会增加复杂度。</li></ul><h2 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a>HashMap的长度为什么是2的幂次方？</h2><ul><li><strong>位运算效率更高</strong>：位运算比取余运算效率更高。当数组长度为2的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</li><li> <strong>扩容机制变得简单高效</strong>：扩容后<font color="#00b0f0">只需要检查哈希值高位的变化</font>来决定元素的新位置，要么位置不变（高位为0），要么就是移动到新位置（高位为1）。</li><li><strong>可以更好的保证哈希值均匀分布</strong>：扩容之后，在旧数组元素hash值分布比较均匀的情况下，新数组元素也会分配的比较均匀，最好的情况是会有一半在新数组的前半部分，另一半在新数组的后半部分。</li></ul><h2 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h2><p>多线程环境下对HashMap进行并发写操作，主要会有两个问题：</p><ol><li><strong>put操作覆盖，数据丢失</strong>：并发put操作可能导致一个线程的写入被另一个线程覆盖。</li><li><strong>无限循环</strong>：在JDK7及以前版本中，并发扩容时，由于头插法可能导致链表形成环，从而在get操作时引发无限循环，cpu飙升至100%。</li></ol><h2 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h2><ul><li><strong>确定位置</strong>：计算key的哈希值，经过扰动函数，结合数组长度计算出存储的索引位置。</li><li><strong>直接插入</strong>：如果数组为空，就触发 <code>resize()</code> 方法进行初始化。然后如果该位置为空，直接插入新节点。</li><li><strong>处理冲突</strong>：如果该位置不为空，则检查头节点是否匹配，如果匹配直接覆盖掉；否则遍历链表/红黑树进行查找或插入（尾插法）。插入后检查链表长度，满足条件则进行树化。</li><li><strong>扩容检查</strong>：如果成功插入了新节点，size会加1。最后判断size是否超过了阈值，如果超过了，就进行扩容。</li></ul><h2 id="ConcurrentHashMap底层原理"><a href="#ConcurrentHashMap底层原理" class="headerlink" title="ConcurrentHashMap底层原理"></a>ConcurrentHashMap底层原理</h2><ul><li><code>ConcurrentHashMap</code>是Java并发包<code>java.util.concurrent</code>下的一个核心类，是一个线程安全的HashMap。在保证线程安全的前提下，通过<strong>降低锁的粒度</strong>来实现最大的并发性能。</li></ul><h3 id="JDK1-7：分段锁（Segment）"><a href="#JDK1-7：分段锁（Segment）" class="headerlink" title="JDK1.7：分段锁（Segment）"></a>JDK1.7：分段锁（Segment）</h3><p><img src="ConcorrentHashMap1.7.png" alt="ConcorrentHashMap1.7"></p><ul><li><strong>底层结构</strong>：<font color="#ff0000">Segment数组+HashEntry数组</font><ul><li>整个Map被分割成多个Segment，每个Segment内部又是一个小的HashMap，管理着自己的HashEntry数组。</li></ul></li><li><strong>锁的粒度</strong>：<font color="#ff0000">Segment本身继承了ReentrantLock</font>，所以每个Segment就是一把可重入锁，不是锁住整个map。并发度就是segment的数量。</li><li><strong>put操作</strong>：首先根据key的哈希值定位到对应的Segment，然后获取这个Segment得到锁，<font color="#ff0000">在锁定的Segment内部进行put操作</font>。</li><li><strong>get操作</strong>：get操作几乎是不加锁的，<font color="#ff0000">依赖volatile关键字</font>保证HashMap数组的内存可见性。</li></ul><h3 id="JDK1-8：CAS-synchronized"><a href="#JDK1-8：CAS-synchronized" class="headerlink" title="JDK1.8：CAS+synchronized"></a>JDK1.8：CAS+synchronized</h3><p><img src="ConcurrentHashMap1.8.png" alt="ConcurrentHashMap1.8"></p><ul><li><strong>底层结构</strong>：<font color="#ff0000">数组+链表+红黑树</font></li><li><strong>锁的粒度</strong>：降低到了哈希桶的头节点</li><li><strong>put操作</strong>：<ul><li>根据key的哈希值计算出数组的槽位</li><li>如果槽位为空，不会加锁，而是<font color="#ff0000">使用CAS尝试原子地将新节点放入</font>，如果失败，则自旋重试。</li><li>如果槽位不为空，即发生冲突了，使用<font color="#ff0000">synchronized关键字锁住这个槽位的头节点</font>。锁住之后，再判断是链表还是红黑树，进行后续的插入或更新操作。</li></ul></li><li><strong>get操作</strong>：get不加锁，node节点的val和next指针都由volatile修饰，保证了内存可见性。</li></ul><h3 id="JDK1-7-vs-JDK1-8"><a href="#JDK1-7-vs-JDK1-8" class="headerlink" title="JDK1.7 vs JDK1.8"></a>JDK1.7 vs JDK1.8</h3><ul><li><strong>锁粒度</strong>：1.7锁segment（是一段数组），1.8锁node（一个节点）。只有在哈希冲突的时候才加锁，大大降低了锁竞争的概率。</li><li><strong>并发性能</strong>：1.8在无冲突的时候完全依赖CAS，性能极高。</li><li><strong>结构</strong>：1.8引入了红黑树，在哈希冲突严重的时候，查询效率也能维持在O(logn)。</li><li><strong>锁的选用</strong>：1.8使用synchronized代替ReentrantLock，是因为JVM对synchronized进行了大量优化，如锁升级，在锁住小代码块的场景下，性能已经不输ReentrantLock。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashMap的底层实现？&quot;&gt;&lt;a href=&quot;#HashMap的底层实现？&quot; class=&quot;headerlink&quot; title=&quot;HashMap的底层实现？&quot;&gt;&lt;/a&gt;HashMap的底层实现？&lt;/h2&gt;&lt;h3 id=&quot;JDK1-8之前&quot;&gt;&lt;a href=&quot;#J</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="集合" scheme="http://lixrangel.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://lixrangel.com/2025/10/25/hua-dong-chuang-kou/"/>
    <id>http://lixrangel.com/2025/10/25/hua-dong-chuang-kou/</id>
    <published>2025-10-24T16:00:00.000Z</published>
    <updated>2026-01-13T12:17:28.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><img src="%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.svg" alt="无重复字符的最长子串"></p><ul><li>pre存储上一个无重复子串的第一个位置</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><img src="%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.svg" alt="找到字符串中所有字母异位词"></p><ul><li><code>i</code>作为外循环，<code>j</code>每次通过<code>i - n + 1</code>计算</li><li>每次都先更新charS，如果<code>j &lt; 0</code>，continue</li><li>循环结束移除charS中的<code>j</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;%E6%97%A0%E9%87%8D%E5%A4%8D%</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="http://lixrangel.com/2025/10/24/shuang-zhi-zhen/"/>
    <id>http://lixrangel.com/2025/10/24/shuang-zhi-zhen/</id>
    <published>2025-10-23T16:00:00.000Z</published>
    <updated>2026-01-13T12:11:54.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a><br><img src="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.svg" alt="盛最多水的容器"></p><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a><br><img src="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.svg" alt="三数之和"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;盛最多水的容器&quot;&gt;&lt;a href=&quot;#盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;盛最多水的容器&quot;&gt;&lt;/a&gt;盛最多水的容器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/container-wi</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="http://lixrangel.com/2025/10/23/ha-xi/"/>
    <id>http://lixrangel.com/2025/10/23/ha-xi/</id>
    <published>2025-10-23T07:27:10.000Z</published>
    <updated>2026-01-13T12:12:07.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a><br><img src="%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.svg" alt="字母异位词分组"></p><ul><li><code>Map&lt;String, List&lt;String&gt;&gt;</code>存储，key排序后的字符串，value是原始真实的字符串</li><li>返回<code>new ArrayList&lt;&gt;(map.values())</code></li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a><br><img src="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.svg" alt="最长连续序列"></p><ul><li>用一个set存储不重复的nums数组；</li><li>遍历set<ul><li>如果set中存在x-1，说明这不是一个连续子数组的最小值；</li><li>如果不存在，说明这是一个连续子数组的最小值，y=x+1，然后不断循环，如果set中存在，y++；</li><li>循环结束后，更新res</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;字母异位词分组&quot;&gt;&lt;/a&gt;字母异位词分组&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagra</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 8.10安装教程（macOS版）</title>
    <link href="http://lixrangel.com/2025/08/20/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/"/>
    <id>http://lixrangel.com/2025/08/20/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/</id>
    <published>2025-08-19T16:00:00.000Z</published>
    <updated>2026-01-14T09:03:03.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从Elasticsearch 8.x开始，官方不再通过Homebrew提供安装包。</p></blockquote><h2 id="1-安装ES"><a href="#1-安装ES" class="headerlink" title="1. 安装ES"></a>1. 安装ES</h2><h3 id="1-1-下载Elasticsearch"><a href="#1-1-下载Elasticsearch" class="headerlink" title="1.1 下载Elasticsearch"></a>1.1 下载Elasticsearch</h3><ul><li>访问<a href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch官方下载页面</a>，选择 8.10.0 版本并下载。</li></ul><h3 id="1-2-解压文件"><a href="#1-2-解压文件" class="headerlink" title="1.2 解压文件"></a>1.2 解压文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf elasticsearch-8.10.0-darwin-x86_64.tar.gz </span><br><span class="line"><span class="built_in">cd</span> elasticsearch-8.10.0</span><br></pre></td></tr></table></figure><h3 id="1-3-启动es"><a href="#1-3-启动es" class="headerlink" title="1.3 启动es"></a>1.3 启动es</h3><ul><li>可以直接进入到 bin 目录，然后执行 <code>./elasticsearch</code> 启动 ES。</li><li>默认情况下，ES 默认是自动配置堆大小的，也就是没有设置固定的内存限制，所以 ES 会根据系统可用内存自动分配，有的时候内存会飙升，可以通过下面的命令运行：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ES_JAVA_OPTS</span>=<span class="string">&quot;-Xms5g -Xmx5g&quot;</span> ./bin/elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p>ES 8.10.0 需要 JDK17 版本</p></blockquote></li></ul><h2 id="2-ES安全功能解除方法"><a href="#2-ES安全功能解除方法" class="headerlink" title="2. ES安全功能解除方法"></a>2. ES安全功能解除方法</h2><ul><li>es的安全功能包括：<ul><li>HTTPS：所有通信默认使用HTTPS。</li><li>身份验证：需要用户名和密码才能访问es。</li><li>证书生成：安装时会自动生成 TLS/SSL 证书。</li></ul></li></ul><h3 id="2-1-方法一：使用HTTPS访问-ES"><a href="#2-1-方法一：使用HTTPS访问-ES" class="headerlink" title="2.1 方法一：使用HTTPS访问 ES"></a>2.1 方法一：使用HTTPS访问 ES</h3><h4 id="2-1-1-找到生成的证书"><a href="#2-1-1-找到生成的证书" class="headerlink" title="2.1.1 找到生成的证书"></a>2.1.1 找到生成的证书</h4><ul><li>CA证书路径：通常位于<code>elasticsearch-8.10.0/config/certs/http_ca.crt</code></li><li>用户名和密码：默认用户是elastic，密码会在启动时生成。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">✅ Elasticsearch security features have been automatically configured!</span><br><span class="line">✅ Authentication is enabled and cluster connections are encrypted.</span><br><span class="line"></span><br><span class="line">ℹ️  Password for the **elastic** user (reset with `bin/elasticsearch-reset-password -u elastic`):</span><br></pre></td></tr></table></figure><blockquote><p>如果忘记了密码，可以通过以下命令重置：<br><code>./bin/elasticsearch-reset-password -u elastic</code></p></blockquote></li></ul><h4 id="2-1-2-使用HTTPS访问"><a href="#2-1-2-使用HTTPS访问" class="headerlink" title="2.1.2 使用HTTPS访问"></a>2.1.2 使用HTTPS访问</h4><ul><li>回到解压目录（不是bin目录），运行以下命令，指定CA证书并使用HTTPS协议：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --cacert config/certs/http_ca.crt -X GET <span class="string">&quot;https://localhost:9201&quot;</span> -u elastic</span><br></pre></td></tr></table></figure><blockquote><p>这里我的9200端口一直显示被占用，所以我换了9201端口。</p></blockquote></li><li>系统会提示输入密码，输入elastic用户的密码后即可访问。</li></ul><h3 id="2-2-访问二：禁用HTTPS和安全功能"><a href="#2-2-访问二：禁用HTTPS和安全功能" class="headerlink" title="2.2 访问二：禁用HTTPS和安全功能"></a>2.2 访问二：禁用HTTPS和安全功能</h3><h4 id="2-2-1-修改配置文件"><a href="#2-2-1-修改配置文件" class="headerlink" title="2.2.1 修改配置文件"></a>2.2.1 修改配置文件</h4><ul><li>编辑 config/elasticsearch.yml 文件，把这两个配置项修改为 false。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span> </span><br><span class="line"><span class="attr">xpack.security.http.ssl.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-2-重启es"><a href="#2-2-2-重启es" class="headerlink" title="2.2.2 重启es"></a>2.2.2 重启es</h4><ul><li>重启es：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-3-使用HTTP访问"><a href="#2-2-3-使用HTTP访问" class="headerlink" title="2.2.3 使用HTTP访问"></a>2.2.3 使用HTTP访问</h4><ul><li>现在可以通过HTTP协议访问es：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="operator">-</span>X <span class="keyword">GET</span> &quot;http://localhost:9201&quot; <span class="operator">-</span>u 用户名:你的密码</span><br></pre></td></tr></table></figure><img src="http%E8%AE%BF%E9%97%AEes.png" alt="http访问es"><blockquote><p>禁用安全功能仅适用于开发环境，生产环境中不建议这样做。<br>如果你在Docker中运行es，请确保将 xpack.security.enabled 设置为 false。</p></blockquote></li></ul><h2 id="3-ES安装IK分词器插件"><a href="#3-ES安装IK分词器插件" class="headerlink" title="3. ES安装IK分词器插件"></a>3. ES安装IK分词器插件</h2><ul><li>IK 分词器是阿里开源的一个中文分词工具，主要用于全文检索和文本分析：<a href="https://github.com/infinilabs/analysis-ik">IK分词器</a></li><li>可以通过命令行直接安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/8.10.0.zip</span><br></pre></td></tr></table></figure></li><li>如果失败的话，使用这个链接下载：<a href="https://release.infinilabs.com/analysis-ik/stable/">IK分词器下载</a><blockquote><p>下载版本必须和es版本相同</p></blockquote></li><li>下载后使用以下命令安装本地插件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install file:YOUR_PATH/elasticsearch-analysis-ik-8.10.0.zip</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从Elasticsearch 8.x开始，官方不再通过Homebrew提供安装包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-安装ES&quot;&gt;&lt;a href=&quot;#1-安装ES&quot; class=&quot;headerlink&quot; title=&quot;1. 安</summary>
      
    
    
    
    
    <category term="es" scheme="http://lixrangel.com/tags/es/"/>
    
    <category term="agent" scheme="http://lixrangel.com/tags/agent/"/>
    
  </entry>
  
  <entry>
    <title>服务器连接hugging face失败</title>
    <link href="http://lixrangel.com/2024/09/16/fu-wu-qi-lian-jie-hugging-face-shi-bai/"/>
    <id>http://lixrangel.com/2024/09/16/fu-wu-qi-lian-jie-hugging-face-shi-bai/</id>
    <published>2024-09-15T16:00:00.000Z</published>
    <updated>2026-01-13T11:57:42.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-启用hf镜像"><a href="#1-启用hf镜像" class="headerlink" title="1. 启用hf镜像"></a>1. 启用hf镜像</h2><p><code>export HF_ENDPOINT=``https://hf-mirror.com</code></p><h2 id="2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source："><a href="#2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source：" class="headerlink" title="2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 source："></a>2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 <code>source</code>：</h2><ul><li><code>source ~/.zshrc</code> (如果你使用的是 Zsh)</li><li><code>source ~/.bashrc</code> (如果你使用的是 Bash)</li></ul><h2 id="3-检查是否启用成功"><a href="#3-检查是否启用成功" class="headerlink" title="3. 检查是否启用成功"></a>3. 检查是否启用成功</h2><p>运行以下命令验证环境变量：<br><code>echo $HF_ENDPOINT</code><br>返回下面的说明成功了：<br><img src="hf-mirror%E5%90%AF%E7%94%A8%E6%88%90%E5%8A%9F.png" alt="启用成功"></p><h2 id="4-获取模型克隆命令"><a href="#4-获取模型克隆命令" class="headerlink" title="4. 获取模型克隆命令"></a>4. 获取模型克隆命令</h2><p>打开 Hugging Face 的模型页面，点击 <strong>Clone repository</strong> 获取地址：<br><img src="hugging_face_clone.png" alt="hugging face model"></p><h2 id="5-安装工具并下载"><a href="#5-安装工具并下载" class="headerlink" title="5. 安装工具并下载"></a>5. 安装工具并下载</h2><p>首先安装官方命令行工具 <code>huggingface_hub</code>，然后使用 <code>hf download</code> 即可高速下载：<br><code>pip install -U &quot;huggingface_hub&quot;</code><br><img src="hf_download.png" alt="hf download"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-启用hf镜像&quot;&gt;&lt;a href=&quot;#1-启用hf镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 启用hf镜像&quot;&gt;&lt;/a&gt;1. 启用hf镜像&lt;/h2&gt;&lt;p&gt;&lt;code&gt;export HF_ENDPOINT=``https://hf-mirror</summary>
      
    
    
    
    
    <category term="服务器" scheme="http://lixrangel.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统与环境的安装与搭建</title>
    <link href="http://lixrangel.com/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/"/>
    <id>http://lixrangel.com/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/</id>
    <published>2022-03-19T07:27:10.000Z</published>
    <updated>2022-03-19T09:40:49.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近计算机系统基础的实验课安装搭建了Linux系统与环境，整个过程我花费了不短的时间，想在这里简单记录一下，也算是以后学习的一个参考吧。</p><h2 id="一、VMware虚拟机的下载"><a href="#一、VMware虚拟机的下载" class="headerlink" title="一、VMware虚拟机的下载"></a>一、VMware虚拟机的下载</h2><hr><h3 id="进入VM官网"><a href="#进入VM官网" class="headerlink" title="进入VM官网"></a>进入VM官网</h3><p>网址：<strong><a href="http://www.vmware.com/">www.vmware.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/1.png" class="" title="官网页面"></div><hr><h3 id="下载VMware-WorkStation-Pro"><a href="#下载VMware-WorkStation-Pro" class="headerlink" title="下载VMware WorkStation Pro"></a>下载VMware WorkStation Pro</h3><h4 id="①在工作空间中找到Workstation-Pro"><a href="#①在工作空间中找到Workstation-Pro" class="headerlink" title="①在工作空间中找到Workstation Pro"></a>①在工作空间中找到Workstation Pro</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/2.png" class="" title="点击Workstation Pro"></div><h4 id="②选择下载试用版（激活码在后面会给出）"><a href="#②选择下载试用版（激活码在后面会给出）" class="headerlink" title="②选择下载试用版（激活码在后面会给出）"></a>②选择下载试用版（激活码在后面会给出）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/3.png" class="" title="下载试用版"></div><h4 id="③选择for-Windows（这里只以Windows系统为例）"><a href="#③选择for-Windows（这里只以Windows系统为例）" class="headerlink" title="③选择for Windows（这里只以Windows系统为例）"></a>③选择for Windows（这里只以Windows系统为例）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/4.png" class="" title="选择for Windows"></div><hr><h2 id="二、VMware虚拟机的安装"><a href="#二、VMware虚拟机的安装" class="headerlink" title="二、VMware虚拟机的安装"></a>二、VMware虚拟机的安装</h2><hr><p>点击下一步完成安装即可</p><p>安装完毕后输入许可密钥（以下是网上找的几个密钥，选择哪一个都可以）：</p><p><strong>ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br> YF390-0HF8P-M81RQ-2DXQE-M2UT6<br> ZF71R-DMX85-08DQY-8YMNC-PPHV8</strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.jpg" class="" title="输入密钥"></div><p>到此，VMware的下载安装已完成，接下来完成对Ubuntu的安装。</p><hr><h2 id="三、Ubuntu的下载"><a href="#三、Ubuntu的下载" class="headerlink" title="三、Ubuntu的下载"></a>三、Ubuntu的下载</h2><hr><h3 id="进入Ubuntu官网"><a href="#进入Ubuntu官网" class="headerlink" title="进入Ubuntu官网"></a>进入Ubuntu官网</h3><p>网址：<strong><a href="http://ubuntu.com/">http://ubuntu.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.png" class="" title="官网页面"></div><hr><h3 id="下载Ubuntu"><a href="#下载Ubuntu" class="headerlink" title="下载Ubuntu"></a>下载Ubuntu</h3><p>点击【Download】</p><p>点击【20.04LTS】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/6.png" class="" title="下载Ubuntu"></div><p><strong>下载位置最好选在一个方便找到的文件夹里，后面会需要该位置</strong></p><hr><h2 id="四、Ubuntu的安装"><a href="#四、Ubuntu的安装" class="headerlink" title="四、Ubuntu的安装"></a>四、Ubuntu的安装</h2><hr><p>打开刚刚安装的VMware，点击【创建新的虚拟机】（Linux将运行在该虚拟机上）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/7.png" class="" title="创建新的虚拟机"></div><p>选择下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/8.png" class="" title="点击下一步"></div><p>选择【稍后安装操作系统】，然后点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/9.png" class="" title="点击下一步"></div><p>选择如下的操作系统和版本</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/10.png" class="" title="选择操作系统和版本"></div><p>选择虚拟机存储位置（最好不要选在系统盘）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/11.png" class="" title="选择虚拟机存储位置"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/12.png" class="" title="点击下一步"></div><p>在自定义硬件中选择合适的内存和处理器，内存给2g足够，根据电脑配置给；处理器默认；网络适配器选择NAT；把不用的打印机移除，否则后面可能会出问题。选择刚才Ubuntu文件的位置。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/13.png" class="" title="点击自定义硬件"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/14.png" class="" title="选择配置"></div><p>设置之后点击【开启虚拟机】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/15.png" class="" title="开启虚拟机"></div><p><strong>注意：这里可能会显示”此主机支持AMD-V，但AMD-V处于禁用状态“，解决办法为”重启电脑系统，进入BIOS设置，将AMD由【disabled】改为【enabled】“（我的电脑是联想小新air14，不同的电脑可能会有微小差别）</strong></p><p>等待其自行加载Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/16.png" class=""></div><p>选择简体中文并安装Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/17.png" class="" title="安装Ubuntu"></div><p>选择chinese点击继续</p><p>注意：这边可能由于屏幕太小看不到下一步，点不到继续按钮，按住alt+f7，此时鼠标变成小手，可以拖到下面。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/18.png" class=""></div><p>选择正常安装之后点击继续（此处最好把网络断开，不要勾选其他选项）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/19.png" class=""></div><p>点击安装</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/20.png" class="" title="点击现在安装"></div><p>点击继续进行下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/21.png" class="" title="点击继续"></div><p>地点直接点击继续即可，个人信息填写完毕之后继续点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/22.png" class="" title="点击继续"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/23.png" class="" title="点击继续"></div><p>等待ubuntu的自行安装即可，安装完成之后重启虚拟机。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/24.png" class="" title="重新启动"></div><p>点击账号输入密码登录</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/25.png" class="" title="登录"></div><p>安装完成之后发现虚拟机未能全屏显示</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/26.png" class="" title="未全屏显示"></div><p>在左上角的虚拟机一栏中选择安装VMware tools</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/27.png" class="" title="安装VMware tools"></div><p>右键提取到桌面并且解压，将解压文件中的vmware-tools-distrib复制到桌面</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/28.png" class="" title="提取解压"></div><p>右键，在终端打开</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/29.png" class="" title="在终端打开"></div><p>输入以下命令进行安装</p><p><strong>sudo ./vmware-install.pl（注意 . 前面有空格）</strong></p><p>在“Do you still want to proceed with this installation?”后的【no】改为【yes】，即可继续。后面都是直接按确定键即可。</p><p>至此，安装全部完成。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/30.png" class="" title="安装完成"></div><hr><p>本篇文章到此就全部结束了</p><p>疫情又严重起来了，大家一定要做好防护啊！</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近计算机系统基础的实验课安装搭建了Linux系统与环境，整个过程我花费了不短的时间，想在这里简单记录一下，也算是以后学习的一个参考吧。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浏览器显示未连接互联网的解决方法</title>
    <link href="http://lixrangel.com/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/"/>
    <id>http://lixrangel.com/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/</id>
    <published>2022-03-06T09:44:29.000Z</published>
    <updated>2022-03-06T10:32:29.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天我一个舍友的浏览器总是显示未连接互联网，试了很多方法都没有解决，于是找到了我这个虽然学计算机但实际上啥也不会的舍友，在度娘的帮助下最后成功解决了。为了下一次遇到同样的问题我可以不再需要询问度娘，我在这里简单记录一下解决方案，同时也算是一个自我提升的过程吧。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><hr><p>请先检查是否真的是网络的问题，比如你的WiFi是否真的连接成功了、你的WiFi是否为可用网络。如果确定不是网络的问题，就可以进入第二步了。</p><hr><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><hr><p>如果确保网络没有问题，接下来请检查是否是浏览器的问题，可以尝试更换浏览器，建议选用Chrome、火狐等浏览器。如果也不是浏览器的问题，就可以进入第三步了。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><hr><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>打开电脑的控制面板</p><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/1.jpg" class="" title="控制面板"></div><hr><h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><ul><li>单击[<strong>网络和Internet</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/7.png" class="" title="单击[网络和Internet]"></div><hr><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><ul><li>单击[<strong>网络和共享中心</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/2.jpg" class="" title="单击[网络和共享中心]"></div><hr><h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><ul><li>单击左下角[<strong>Internet选项</strong>]</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/3.png" class="" title="单击[Internet选项]"></div><hr><h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><ul><li>选择上方的[<strong>连接</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/4.png" class="" title="选择[连接]"></div><hr><h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><ul><li>单击[<strong>局域网设置</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/5.png" class="" title="单击[局域网设置]"></div><hr><h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><ul><li>将[<strong>为LAN使用代理服务器</strong>]前的勾选取消</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/6.jpg" class="" title="取消勾选"></div><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr><p>如果通过上述步骤还是没有解决，可以自行寻求其他解决方案。由于我的技术水平十分有限，可能无法给出更多的解决方法，非常抱歉！</p><hr><p>距离我上一次更新已经过去了四个多月，主要原因还是我太懒了（惭愧），希望之后我能够督促我自己多多记录吧。</p><p>春天来啦，希望大家都能好好生活！</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天我一个舍友的浏览器总是显示未连接互联网，试了很多方法都没有解决，于是找到了我这个虽然学计算机但实际上啥也不会的舍友，在度娘的帮助下最后</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂记（二）</title>
    <link href="http://lixrangel.com/2021/10/26/za-ji-er/"/>
    <id>http://lixrangel.com/2021/10/26/za-ji-er/</id>
    <published>2021-10-26T10:45:24.000Z</published>
    <updated>2026-01-13T10:13:32.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h2><hr><p>距离我上一篇文章发布已经过去了三个多月，这三个多月的空余大部分原因是我太懒了，其实在写这篇文章的时候我正在上课，至于是什么课就不说了，万一老师看到了我的网站呢（我瞎说的，怎么可能）。为了督促我自己坚持记录，就在这篇里面随便聊点什么吧（由于老师的声音还不断地进入我的耳朵，所以可能逻辑不是很通顺，还请见谅）</p><ul><li><p>由于南京的疫情，我在两周前才返回校园，还上了两个星期网课，今天是线下课的第二天。也就是说，开学快两个月了，有些老师和同学长什么样我还不知道（so sad）。在我回到学校的那天，其实做了超级大的心理建设，毕竟整整三个月，无法想象那窄小的宿舍会变成什么德行。Fortunately，它并没有发霉，但是还是有一股巨大的潮味，我用了差不多一个星期才缓过来。两个星期过去，生活已经差不多步入了正轨，也是为了再次开启新的生活，我写下了这篇文章。</p></li><li><p>这个学期，我也正式进入了专业学习。由于培养方案的更改，我这学期能修的课少的可怜，还在为之后痛苦的生活嘤嘤嘤。在学习的过程中，我也深刻认识到自己的不足，好像没有太多的精力应付所有的事情，能够把基础打好都已经筋疲力竭了。在平时的生活中，我也有意识地关注一些计算机相关的信息，除了能从中收获一些知识之外，还会产生深深的焦虑，这种焦虑与我学习过程中的困难相互叠加，让我产生了较大的自我怀疑。所以这几天，我一直在尝试消化这种情绪，不知道大家有没有什么比较好的方法，欢迎与我交流，非常感谢！</p></li><li><p>在我写下这篇文章的前两天，南航实验室发生爆炸，使得我这两天的心情也比较沉重。关于这件令人心痛与惋惜的事我不做太多的评价，但是，真诚地希望，所有正在或即将为科研事业奋斗的学生们能够健康平安，在保护好自己的前提下为国家科研事业奉献。</p></li><li><p>最近我开始尝试使用Spotify，最大的体验感受为——歌词界面我好喜欢！对于我这种重度歌词爱好者来说，实在是太完美了吧，我贴个图片。</p></li></ul><div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji-er/1.png" class="" title="搜索界面"></div> <div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji-er/2.png" class="" title="歌词界面"></div><ul><li><p>除此之外，还有我未曾谋面的陌生人给予了我巨大的鼓励，让我对爱与勇气有了更加深刻的思考，在这里也对她们说一声谢谢。</p></li><li><p>之前说的驾考之旅记录有机会的话我也会写一下（毕竟真的太过drama了</p></li></ul><hr><p>秋天也快要过去啦，大家做好保暖措施呀</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些碎碎念&quot;&gt;&lt;a href=&quot;#一些碎碎念&quot; class=&quot;headerlink&quot; title=&quot;一些碎碎念&quot;&gt;&lt;/a&gt;一些碎碎念&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;距离我上一篇文章发布已经过去了三个多月，这三个多月的空余大部分原因是我太懒了，其实在写这篇文章的时候我正在</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://lixrangel.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>杂记（一）</title>
    <link href="http://lixrangel.com/2021/08/06/za-ji-yi/"/>
    <id>http://lixrangel.com/2021/08/06/za-ji-yi/</id>
    <published>2021-08-06T05:33:22.000Z</published>
    <updated>2026-01-13T10:13:43.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="part1-OpenGL学习记录"><a href="#part1-OpenGL学习记录" class="headerlink" title="part1 OpenGL学习记录"></a>part1 OpenGL学习记录</h2><hr><h3 id="lesson-01"><a href="#lesson-01" class="headerlink" title="lesson 01"></a>lesson 01</h3><ul><li>在第一课配置环境这一部分我其实就遇到了困难 开始用VS2019配置 后来发现代码不一样没办法用教程的代码继续往下  于是转战VC6.0 比用VS2019简易多了</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/1.png" class="" title="这是我的第一个OpenGL窗口"></div><hr><h3 id="lesson-02"><a href="#lesson-02" class="headerlink" title="lesson 02"></a>lesson 02</h3><ul><li>这节课我创建了第一个（其实是两个）多边形 惭愧的是函数代码我至今还没有记住（so sad）</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/2.png" class="" title="这是我的第一个多边形"></div><hr><h3 id="lesson-03"><a href="#lesson-03" class="headerlink" title="lesson 03"></a>lesson 03</h3><ul><li>开始添加颜色啦 教程里设置的颜色还挺好看的嘿嘿</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/3.png" class="" title="有颜色的多边形"></div><hr><h3 id="lesson-04-amp-lesson-05"><a href="#lesson-04-amp-lesson-05" class="headerlink" title="lesson 04&amp;lesson 05"></a>lesson 04&amp;lesson 05</h3><ul><li>第四课学的是旋转 但我忘记录视频了（哭）</li><li>这一节课终于开始画立体的图形了 我创建了一个金字塔和立方体 除了颜色之外还加入了旋转 这是有意思的开始</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/5.gif" class="" title="这是旋转的立体图形"></div><hr><h3 id="lesson-06"><a href="#lesson-06" class="headerlink" title="lesson 06"></a>lesson 06</h3><ul><li>学会添加纹理啦 终于可以放上自己喜欢的图片了（但其实图片都是朋友给的 选择困难症的我实在是不知道该放哪几张） 我在这里修改了教程的代码 我创建了6个纹理 也就是在立方体的六个面都可以放入图片 虽然花费了很长时间 但最后实现了还是很开心！</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/6.gif" class="" title="放的图片是朋友给的"></div><hr><h3 id="lesson-07-amp-lesson-08"><a href="#lesson-07-amp-lesson-08" class="headerlink" title="lesson 07&amp;lesson 08"></a>lesson 07&amp;lesson 08</h3><ul><li>这两节课是光照和键盘控制以及混合 好复杂 我学的不是很懂 还是要找机会把代码熟练一下 现在真的是太菜了（大哭）</li></ul><hr><h3 id="还有一些想说的"><a href="#还有一些想说的" class="headerlink" title="还有一些想说的"></a>还有一些想说的</h3><ul><li>在这里要感谢Nehe 他多年前的教程对现在的我依旧有很大启发</li><li>总而言之 在OpenGL学习的过程中发现了很多乐趣 但也深刻认识到自己的不足 有时候会自我怀疑是不是真的能学好 我对这些想法的解决办法是 熬呗 哪能咋整</li><li>距离我上一次学习已经过去了十多天了 不知道下一次会是什么时候 我尽力在每一次学习之后总结一下我的感受 以激励不知道何时会到来的下一次</li></ul><hr><h2 id="part2-一些推荐"><a href="#part2-一些推荐" class="headerlink" title="part2 一些推荐"></a>part2 一些推荐</h2><hr><ul><li><h3 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a><strong>电视剧</strong></h3><ul><li>机智的医生生活2——没有人不爱看机医=没有人不需要被治愈 每一集都在笑与泪中度过 没有人会不想成为蔡颂华 建议先看第一季 也非常好看 第二季目前更新到第七集 品质是一如既往 所以不必太担心（写完这一篇我就要去看第七集了 开心嘿嘿</li><li>我在他乡挺好的——致郁与治愈并存 每一集都让人直呼太真实了 目前更新到第十集 如果不烂尾 目测是今年的高分国产剧了</li><li>浪漫医生金师傅——由于上面两部剧更新的实在太慢了 于是我把浪漫医生金师傅又掏出来看了一遍 依旧能感受到巨大的温暖 第二季没有第一季好看我个人认为（<del>第二季男女主真的很不喜欢</del>）（<del>如果找不到资源的话可以联系我</del>）</li></ul></li><li><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a><strong>播客</strong></h3><ul><li>谐星聊天会——我昨天听的是大学寝室奇闻录那一期节目 内容是这几个主讲人分享他们大学寝室里有趣的人和事 这几个人真的很有趣 听的时候我就不断感叹他们的大学生活好精彩 他们的大学同学也好精彩 导致我一个多小时都沉浸在他们的聊天中</li></ul></li></ul><p>​       播客是我最近才发觉的一种很有趣的分享方式 是在豆瓣上看了一个小众圈子的组长的主页 听了一两期节目才被吸引到 由于还没有接触太多所以没办法讲我喜欢的一些播客 但到目前为止 我最大的想法是：<strong>好想做一个自己的播客节目啊</strong> 但目前只是一个想法 具体的实现还没有纳入计划 所以 <strong>有兴趣的朋友请狠狠地戳我</strong> 我们可以一起交流一下 如果能碰撞出不一样的火花 我可能就会开始实践了</p><hr><p>这一篇到这里就要结束了</p><p>现在疫情又严重了 希望大家都能保护好自己</p><p>欢迎志同道合的朋友与我交流</p><p>我们下一篇见</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;part1-OpenGL学习记录&quot;&gt;&lt;a href=&quot;#part1-OpenGL学习记录&quot; class=&quot;headerlink&quot; title=&quot;part1 OpenGL学习记录&quot;&gt;&lt;/a&gt;part1 OpenGL学习记录&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;less</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://lixrangel.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://lixrangel.com/2021/07/31/guan-yu-wo/"/>
    <id>http://lixrangel.com/2021/07/31/guan-yu-wo/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2026-01-13T08:59:15.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>欢迎来到我的世界</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a><strong>关于我</strong></h2><ul><li><p>随时随地在coding的女孩</p></li><li><p>学历：</p><ul><li>本科：南京师范大学 计算机科学与技术专业</li><li>硕士：华东师范大学 计算机科学与技术专业（推免）    </li></ul></li><li><p>能好好活着是我最大的愿望</p></li></ul><hr><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a><strong>爱好</strong></h2><ul><li><p>因为没有什么爱好所以什么都可以是我的爱好</p><ul><li>足球——Hala Madrid！</li><li>追剧——什么都看一点</li><li>coding——努力变得更强中</li></ul></li><li><p>其他的还有待挖掘，欢迎和我交流。</p></li></ul><hr><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a><strong>社交</strong></h2><ul><li><p><strong>微博/QQ/微信</strong>   重度依赖症患者</p></li><li><p><strong>豆瓣/知乎/CSDN</strong>   偶尔使用</p></li><li><p><strong>Instagram/X/Line</strong>    这些真的挺难用的我觉得 但有时候不得不…（你懂的）<del>坏笑</del></p></li></ul><hr><h2 id="信念"><a href="#信念" class="headerlink" title="信念"></a><strong>信念</strong></h2><p><em>经济独立 精神独立 好好活着</em></p><hr><p>本Blog旨在记录一些我自己学习生活过程中的心得体会 所以文章大概都是随心写哈哈哈</p><p>本网站依旧在开发中 如果有任何建议欢迎给我发邮件：<a href="mailto:&#49;&#x31;&#55;&#x39;&#x34;&#x32;&#54;&#x32;&#54;&#56;&#x6c;&#x78;&#x72;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#49;&#x31;&#55;&#x39;&#x34;&#x32;&#54;&#x32;&#54;&#56;&#x6c;&#x78;&#x72;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a><br>很希望能找到志同道合的朋友一起交流 如果有朋友愿意跟我聊聊的 也欢迎给我发邮件<br>我暂时就想到这么多 未完待续…<br>感谢你的阅读 祝你生活愉快！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;欢迎来到我的世界&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;关于我&quot;&gt;&lt;a href=&quot;#关于我&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
