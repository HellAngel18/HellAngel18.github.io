<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>地狱天使&#39;s Blog</title>
  
  <subtitle>欢迎来到我的世界</subtitle>
  <link href="http://lixrangel.com/atom.xml" rel="self"/>
  
  <link href="http://lixrangel.com/"/>
  <updated>2026-01-26T08:10:34.831Z</updated>
  <id>http://lixrangel.com/</id>
  
  <author>
    <name>地狱天使</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://lixrangel.com/2025/12/30/java-ba-gu/redis/redis-fen-bu-shi-suo/"/>
    <id>http://lixrangel.com/2025/12/30/java-ba-gu/redis/redis-fen-bu-shi-suo/</id>
    <published>2025-12-29T16:00:00.000Z</published>
    <updated>2026-01-26T08:10:34.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis分布式锁的实现原理？"><a href="#Redis分布式锁的实现原理？" class="headerlink" title="Redis分布式锁的实现原理？"></a>Redis分布式锁的实现原理？</h2><p><img src="redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="redis分布式锁"></p><ul><li>Redis本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且redis的读写性能高，可以应对高并发的锁操作场景。Redis的SET命令有个<strong>NX参数可以实现「key不存在才插入」</strong>，所以可以用它来实现分布式锁：<ul><li>如果key不存在，表示加锁成功；</li><li>如果key存在，说明已经有人正在改，表示加锁失败。</li></ul></li><li>基于Redis节点实现分布式锁时，对于加锁操作，我们需要满足三个条件：<ul><li>加锁包括了<strong>读取锁变量</strong>、<strong>检查锁变量</strong>和<strong>设置锁变量值</strong>三个操作，但需要以原子操作的方式完成，所以使用SET命令带上NX选项来实现加锁；</li><li><strong>锁变量需要设置过期时间</strong>，以免客户端拿到锁后发生异常，导致锁一致无法释放，所以在SET命令执行时加上EX/PX选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，会释放其他客户端的锁，所以使用SET命令设置锁变量值时，<strong>每个客户端设置的值是一个唯一值</strong>，用于标识客户端；</li></ul></li><li>满足这三个条件的分布式命令如下，可以实现原子加锁：<code>SET lock_key unique_value NX PX 10000</code><ul><li><code>lock_key</code>就是key键；</li><li><code>unique_value</code>是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li><code>NX</code>代表只在lock_key不存在时，才对lock_key进行设置操作；</li><li><code>PX 1000</code>表示设置lock_key的过期时间为10s，这是为了避免客户端发生异常而无法释放锁。</li></ul></li><li>而解锁的过程就是将lock_key键删除（<code>del lock_key</code>），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以解锁的时候，要先判断锁的<code>unique_value</code>是否为加锁客户端，是的话，才将lock_key键删除。</li><li>可以看到，解锁是有<strong>判断身份+删除两个操作</strong>，这时就需要<strong>lua脚本</strong>来保证解锁的原子性，因为Redis在执行lua脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">//</span> 释放锁时，先比较 unique_value 是否相等，避免锁的误释放 <span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span> <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="如果业务没跑完锁过期了怎么办？"><a href="#如果业务没跑完锁过期了怎么办？" class="headerlink" title="如果业务没跑完锁过期了怎么办？"></a>如果业务没跑完锁过期了怎么办？</h3><ul><li>Redisson的Watch Dog（看门狗）</li><li>自动续期：<ul><li>当你加锁时不设置具体的过期时间，Redisson默认设置30s；</li><li>它会<strong>启动一个后台守护线程（Watch Dog）</strong>；</li><li>每隔10s它会检查一下，该线程是否还持有这把锁；</li><li>如果还在，<strong>就重置过期时间为30s</strong></li></ul></li><li>这就实现了，只要业务在跑，锁就永不过期；业务一停，锁在30s后自动释放。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis分布式锁的实现原理？&quot;&gt;&lt;a href=&quot;#Redis分布式锁的实现原理？&quot; class=&quot;headerlink&quot; title=&quot;Redis分布式锁的实现原理？&quot;&gt;&lt;/a&gt;Redis分布式锁的实现原理？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;redis%E5</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="http://lixrangel.com/2025/12/29/java-ba-gu/redis/redis-ji-qun/"/>
    <id>http://lixrangel.com/2025/12/29/java-ba-gu/redis/redis-ji-qun/</id>
    <published>2025-12-28T16:00:00.000Z</published>
    <updated>2026-01-26T07:36:02.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h2><p>单节点的redis并发能力是有上限的，要进一步提高redis的并发能力，就需要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据。</p><h3 id="完全同步"><a href="#完全同步" class="headerlink" title="完全同步"></a>完全同步</h3><ul><li>发生情况：<ul><li><strong>初次同步</strong>：当一个从服务器（slave）首次连接到主服务器（master）时，会进行一次完全同步。</li><li><strong>从服务器数据丢失</strong>：如果从服务器数据因为某种原因（如断电）丢失，会请求进行完全同步。</li><li><strong>主服务器数据发生变化</strong>：如果从服务器长时间未与主服务器同步，导致数据差异太大，也可能触发完全同步。</li></ul></li><li>完全同步过程：<ol><li><strong>从节点发送命令</strong>：从节点向主节点发送<code>PSYNC ? -1</code>命令，请求同步数据（-1表示我是新来的，没有之前的同步速度）。</li><li><strong>主节点确认同步</strong>：主节点收到命令后，判断需要进行完全同步，于是返回<code>FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>。<ul><li><code>runid</code>：主节点的运行id；</li><li><code>offset</code>：当前的复制偏移量。</li><li>从节点保存这些信息。</li></ul></li><li><strong>fork子进程生成RDB</strong>：主节点执行<code>BGSAVE</code>命令，fork出一个子进程，将当前内存中的全量数据生成RDB快照文件。</li><li><strong>主节点发送RDB</strong>：RDB生成完成后，主节点通过网络将该文件发送给从节点。</li><li><strong>从节点加载</strong>：从节点接收完RDB文件后，会先清空自己当前数据库中的所有数据库，将RDB文件写入本地磁盘，然后再从本地磁盘加载到内存。这个过程中<font color="#ff0000">从节点会阻塞</font>。（在清空旧数据之前，从节点依然会基于旧的数据版本对外提供服务）。</li><li><strong>写入缓冲区</strong>：在主节点生成和发送RDB的这段时间里，<font color="#ff0000">主节点并没有阻塞写操作</font>。所有新接收到的写命令，会被写入到专门为该从节点分配的<font color="#ff0000">Replication Buffer（复制缓冲区）</font>中。</li><li><strong>发送缓冲命令</strong>：当从节点RDB加载完成后，通知主节点。主节点将Replication Buffer 中<font color="#ff0000">积压的所有写命令发送给从节点</font>。</li><li><strong>最终一致</strong>：<font color="#ff0000">从节点执行这些写命令</font>，此时主从节点的数据状态达到一致。之后双方进入“命令传播”阶段，进行持续的增量同步。<br><img src="Redis%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="Redis全量复制"></li></ol></li></ul><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul><li>增量同步是“断网重连”后的补救措施。</li><li>增量同步过程：<ol><li>从服务器在恢复网络后，会发送<code>PSYNC</code>命令给主服务器，此时的<code>PSYNC</code>命令里的offset参数不是-1；</li><li>主服务器收到该命令后，然后用<code>CONTINUE</code>响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务器将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ol></li><li>但是出现以下两种情况，增量同步会强制转为全量同步：<ul><li><strong>RunID不匹配</strong>：说明master重启过，或者slave连到了一个新的master。</li><li><strong>积压缓冲区溢出</strong>：slave掉线时间太长，导致所需的offset数据在环形缓冲区中已经被新数据覆盖了。此时master找不到就数据，只能发起全量同步。</li></ul></li><li>主服务器怎么知道要将哪些增量数据发送给从服务器呢？<ul><li><code>repl_backlog_buffer</code>，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；</li><li><code>replication offset</code>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用<code>master_repl_offset</code>来记录自己「写」到的位置，从服务器使用<code>slave_repl_offset</code>来记录自己「读」到的位置。</li><li>如果判断出从服务器要复制的数据还在<code>repl_backlog_buffer</code>中，就执行增量同步；如果要复制的数据已经不在<code>repl_backlog_buffer</code>中，也就是这个期间主服务器更新了太多写命令覆盖掉了，那么就要执行完全同步。</li></ul></li></ul><h2 id="哨兵机制（Redis-Sentinel）"><a href="#哨兵机制（Redis-Sentinel）" class="headerlink" title="哨兵机制（Redis Sentinel）"></a>哨兵机制（Redis Sentinel）</h2><p>当redis集群的主节点故障时，Sentinel集群将从剩余的从节点中选举一个新的主节点，有以下步骤：</p><ol><li><strong>故障节点主观下线</strong>：Sentinel集群的每一个Sentinel节点会定时对redis集群的所有节点发心跳包检测节点是否正常。如果一个节点在<code>down-after-milliseconds</code>时间内没有回复Sentinel节点的心跳包，则该redis节点被该Sentinel节点主观下线。</li><li><strong>故障节点客观下线</strong>：当节点被一个Sentinel节点记为主观下线时，还需要Sentinel集群的其他Sentinel节点共同判断为主观下线才行。该Sentinel节点会询问其他Sentinel节点，如果Sentinel集群中超过<code>quorum</code>数量的Sentinel节点认为该redis节点主观下线，则该redis节点客观下线。如果客观下线的redis节点是从节点或者是Sentinel节点，则操作到此为止；如果<font color="#ff0000">客观下线的redis节点为主节点，则开始故障转移</font>，从从节点中选举一个节点升级为主节点。</li><li><strong>Sentinel集群选取leader</strong>：如果需要从redis集群选举一个节点为主节点，首先需要<font color="#ff0000">从Sentinel集群中选举一个Sentinel节点作为leader</font>。每一个Sentinel节点都可以成为leader，当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求（选举票数+1），否则不同意。如果一个Sentinel节点获得的选举票数达到leader最低票数（<code>quorum</code>和Sentinel节点数/2 + 1的最大值），则该Sentinel节点选举为leader，否则重新进行选举。</li><li><strong>Sentinel leader决定新主节点</strong>：当Sentinel集群选举出Sentinel leader后，由Sentinel leader从redis从节点中选择一个redis节点作为主节点：<ul><li>过滤故障（网络状况不好）的节点，就是主节点和从节点断开的时间太大。</li><li>选择优先级<code>slave-priority</code>（可以通过配置文件配置）最大的从节点作为主节点，如果不在则继续。</li><li>如果<code>slave-priority</code>一样，则判断slave节点的offset值，最大优先级越高，也就是复制进度最大的从节点。</li><li>最后是判断slave节点运行id的大小，越小优先级越高。<br><img src="redis%E9%80%89%E4%B8%BE%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9.png" alt="redis选举新主节点"></li></ul></li></ol><h2 id="Redis集群模式（Redis-Cluster）"><a href="#Redis集群模式（Redis-Cluster）" class="headerlink" title="Redis集群模式（Redis Cluster）"></a>Redis集群模式（Redis Cluster）</h2><ul><li>当Redis缓存数据量大到一台服务器无法缓存时，就需要使用Redis切片集群（Redis Cluster）方案，<strong>它将数据分布在不同的服务器上</strong>（多个master，每个master多个slave），以此来降低系统对单主节点的依赖，从而提高Redis服务的读写性能。</li><li>Redis Cluster方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。一个切片集群共有16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的key，被映射到一个哈希槽中，具体执行过程分为两大步：<ul><li>根据键值对的key，按照CRC16算法计算一个16bit的值。</li><li>再用16bit值对16384取模，得到0～16383范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis主从同步&quot;&gt;&lt;a href=&quot;#Redis主从同步&quot; class=&quot;headerlink&quot; title=&quot;Redis主从同步&quot;&gt;&lt;/a&gt;Redis主从同步&lt;/h2&gt;&lt;p&gt;单节点的redis并发能力是有上限的，要进一步提高redis的并发能力，就需要搭建主</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis场景</title>
    <link href="http://lixrangel.com/2025/12/28/java-ba-gu/redis/redis-chang-jing/"/>
    <id>http://lixrangel.com/2025/12/28/java-ba-gu/redis/redis-chang-jing/</id>
    <published>2025-12-27T16:00:00.000Z</published>
    <updated>2026-01-26T07:34:19.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要用redis？"><a href="#为什么要用redis？" class="headerlink" title="为什么要用redis？"></a>为什么要用redis？</h2><ul><li><strong>访问速度更快</strong>：传统数据库数据保存在磁盘，而Redis基于内存，内存的访问速度比磁盘快很多。引入Redis之后，我们可以把一些高频访问的数据放到Redis中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。</li><li><strong>高并发</strong>：<font color="#ff0000">单台设备的Redis的QPS是MySQL的10倍</font>，Redis单机的QPS能轻松破10w，而MySQL单机的QPS很难破1w。所以，直接访问Redis能够承受的请求是远远大于直接访问MySQL的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li><li><strong>功能全面</strong>：Redis除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大。</li></ul><h2 id="为什么Redis比MySQL快？"><a href="#为什么Redis比MySQL快？" class="headerlink" title="为什么Redis比MySQL快？"></a>为什么Redis比MySQL快？</h2><ul><li><strong>内存存储</strong>：Redis是基于内存存储的NoSQL数据库，而MySQL是基于磁盘存储的关系型数据库。由于内存存储速度快，Redis能够更快地读取和写入数据，而无需像MySQL那样频繁进行磁盘I/O操作。</li><li><strong>简单数据结构</strong>：Redis是基于键值对存储数据的，支持简单的数据结构（字符串、哈希、列表、集合、有序集合）。相比之下，MySQL需要定义表结构、索引等复杂的关系型数据结构，因此在某些场景下Redis的数据操作更为简单高效，比如Redis用哈希表查询，只需要O(1)时间复杂度，而MySQL引擎的底层实现是B+树，时间复杂度是O(logn)。</li><li><strong>线程模型</strong>：Redis采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li></ul><h2 id="为什么用Redis而不用本地缓存？"><a href="#为什么用Redis而不用本地缓存？" class="headerlink" title="为什么用Redis而不用本地缓存？"></a>为什么用Redis而不用本地缓存？</h2><table><thead><tr><th>特性</th><th>本地缓存</th><th>Redis</th></tr></thead><tbody><tr><td>数据一致性</td><td>多服务器部署时存在数据不一致问题</td><td>数据一致</td></tr><tr><td>内存限制</td><td>受限于单台服务器内存</td><td>独立部署，内存空间更大</td></tr><tr><td>数据丢失风险</td><td>服务器宕机数据丢失</td><td>可持久化，数据不易丢失</td></tr><tr><td>管理维护</td><td>分散，管理不便</td><td>集中管理，提供丰富的管理工具</td></tr><tr><td>功能丰富性</td><td>功能有限，通常只能提供简单的键值对存储</td><td>功能丰富，支持多种数据结构和功能</td></tr></tbody></table><h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul><li><strong>缓存</strong>：Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载。</li><li><strong>排行榜</strong>：Redis的有序集合结构非常适合用于实现排行榜和排名系统，可以方便地进行数据排序和排名。</li><li><strong>分布式锁</strong>：Redis的特性可以用来实现分布式锁，确保多个进程或服务之间的数据操作的原子性和一致性。</li><li><strong>计数器</strong>：由于Redis的原子操作和高性能，它非常适合用于实现计数器和统计数据的存储，如网站访问量统计、点赞数统计等。</li><li><strong>消息队列</strong>：Redis的发布订阅功能使其成为一个轻量级的消息队列，它可以用来实现发布和订阅模式，以便实时处理消息。使用List的方式通常是使用LPUSH命令将消息推入一个列表，消费者使用BLPOP或BRPOP阻塞地从列表中取出消息（先进先出FIFO）。这种方式可以实现简单的任务队列。</li><li><strong>延时队列</strong>：Redisson内置了延时队列（基于Sorted Set实现的）。<h2 id="Redis分布式锁的实现原理"><a href="#Redis分布式锁的实现原理" class="headerlink" title="Redis分布式锁的实现原理"></a>Redis分布式锁的实现原理</h2></li><li>当使用redisson实现分布式锁，底层是<code>setnx</code>和lua脚本（保证释放锁时的原子性）。</li><li>Redis实现分布式锁的核心命令是<code>set</code>：<ul><li>命令：<code>SET lock_key unique_value NX PX 30000</code></li><li>核心参数：<ul><li>NX（Not Exists）：只有当key不存在时才设置成功。</li><li>PX（Expiration）：设置过期时间。这保证了安全性，防止某个客户端挂掉后锁永远不释放。</li><li>unique_value：每个客户端生成的唯一标识（如UUID）。防止A删掉了B的锁。</li></ul></li></ul></li><li>释放锁时，不能简单地执行<code>DEL</code>，因为可能出现以下情况：<ul><li>A加锁成功，执行业务时间太长，锁过期自动释放了。</li><li>B随即获取了锁。</li><li>A业务执行完，直接DEL，直接把B的锁给删了。</li></ul></li><li>因此，为了保证释放锁的安全性，必须验证唯一标识。由于“查询-比较-删除”是三个操作，为了保证原子性，必须使用lua脚本执行。</li></ul><h3 id="如果业务没执行完，锁过期了怎么办？"><a href="#如果业务没执行完，锁过期了怎么办？" class="headerlink" title="如果业务没执行完，锁过期了怎么办？"></a>如果业务没执行完，锁过期了怎么办？</h3><p>Redisson启动后，如果业务没完，会开启一个后台线程（Watch Dog），每隔一段时间（默认10秒）检查一下，如果客户端还持有锁，就自动延长锁的生存时间，防止锁提前过期。</p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><ul><li>原理：Redisson利用Redis的Hash数据结构。key是锁名，Field是客户端ID，Value是计数器。</li><li>逻辑：同一线程再次获取锁时，计数器+1；释放锁时，计数器-1。当计数器为0时，彻底删除key。</li></ul><h2 id="什么是大key？"><a href="#什么是大key？" class="headerlink" title="什么是大key？"></a>什么是大key？</h2><ul><li>如果一个key对应的value所占用的内存比较大，那这个key就可以看作是大key。</li><li>具体多大算大？<ul><li>String类型的value超过1MB；</li><li>复合类型的value包含的元素超过5000个。</li></ul></li></ul><h2 id="大key造成的问题"><a href="#大key造成的问题" class="headerlink" title="大key造成的问题"></a>大key造成的问题</h2><ul><li><strong>内存占用过高</strong>。大key占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis实例崩溃，影响系统的稳定性。</li><li><strong>性能下降</strong>。大key会占用大量内存空间，导致内存碎片增加，进而影响Redis的性能。对于大key的操作，如读取、写入、删除等，都会<font color="#ff0000">消耗更多的CPU时间和内存资源</font>，进一步降低系统性能。</li><li><strong>客户端超时阻塞</strong>。由于Redis执行命令是<font color="#ff0000">单线程处理</font>，在操作大key时会比较耗时，可能会导致Redis实例阻塞。例如，使用DEL命令删除一个大Key时，可能会导致Redis实例<font color="#ff0000">在一段时间内无法响应其他客户端请求</font>，从而影响系统的响应时间和吞吐量。</li><li><strong>网络拥塞</strong>。每次<font color="#ff0000">获取大key产生的网络流量较大</font>，可能造成机器或局域网的带宽被打满，同时波及其他服务。例如：一个大key占用空间是1MB，每秒访问1000次，就有1000MB的流量。</li><li><strong>主从同步延迟</strong>。当Redis实例配置了主从同步时，大key可能导致主从同步延迟。由于大key占用较多内存，同步过程中需要传输大量数据，这会导致<font color="#ff0000">主从之间的网络传输延迟增加</font>，进而影响数据一致性。</li><li><strong>数据倾斜</strong>。在redis集群模式中，某个数据分片的内存使用率远超其他数据分片，<font color="#ff0000">无法使数据分片的内存资源达到均衡</font>。另外也可能造成redis内存达到<code>maxmemory</code>参数定义的上线导致重要的key被逐出，甚至引发内存溢出。</li></ul><h2 id="如何处理大key？"><a href="#如何处理大key？" class="headerlink" title="如何处理大key？"></a>如何处理大key？</h2><ul><li><strong>对大key进行拆分</strong>。例如将含有数万成员的一个hash key拆分为多个hash key，并确保每个key的成员数量在合理范围。在redis集群架构中，拆分大key能对数据分片间的内存平衡起到显著作用。</li><li><strong>对大key进行清理</strong>。将不适用redis能力的数据存至其他存储，并在redis中删除此类数据。</li><li><strong>监控redis的内存水位</strong>。可以通过监控系统设置合理的redis内存报警阈值进行提醒，例如redis内存使用率超过70%、redis内存在1小时内增长率超过20%等。</li><li><strong>对过期数据进行定期清理</strong>。堆积大量过期数据会造成大key的产生，例如在hash数据类型中以增量的形式不断写入大量数据而忽略了数据的时效性。可以通过定时任务的方式对失效数据进行清理。</li></ul><h2 id="什么是热key？"><a href="#什么是热key？" class="headerlink" title="什么是热key？"></a>什么是热key？</h2><p>如果一个key的<strong>访问次数比较多且明显多于其他key</strong>的话，那这个key就可以看作是hot key。例如在redis实例的每秒处理请求达到5000次，而其中某个key的每秒访问量就高达2000次，那这个key就可以看作是hot key。</p><h2 id="如何解决热key？"><a href="#如何解决热key？" class="headerlink" title="如何解决热key？"></a>如何解决热key？</h2><ul><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li><li><strong>使用Redis Cluster</strong>：将热点数据分散存储在多个Redis节点上。</li><li><strong>二级缓存</strong>：hot key采用二级缓存的方式进行处理，将hot key存放一份到JVM本地内存中。</li></ul><h2 id="如何保证缓存和数据库的一致性？"><a href="#如何保证缓存和数据库的一致性？" class="headerlink" title="如何保证缓存和数据库的一致性？"></a>如何保证缓存和数据库的一致性？</h2><h3 id="旁路缓存模式（Cache-Aside-Pattern）"><a href="#旁路缓存模式（Cache-Aside-Pattern）" class="headerlink" title="旁路缓存模式（Cache Aside Pattern）"></a>旁路缓存模式（Cache Aside Pattern）</h3><ul><li><strong>读操作</strong>：<ul><li>先尝试从缓存读取数据</li><li>如果缓存命中，直接返回数据</li><li>如果缓存未命中，从数据库查询数据，将查到的数据放入缓存并返回数据</li></ul></li><li><strong>写操作</strong>：<ul><li>先更新数据库</li><li>再删除缓存中对应的数据<br>如果更新数据库成功，则删除缓存这一步失败的情况的话，简单说有几个解决方案：</li></ul></li><li><strong>增加缓存更新重试机制（常用）</strong>：如果缓存服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。不过，这里更适合引入消息队列实现异步重试，将删除缓存重试的消息投递到消息对立额，然后由专门的消费者来重试，直到成功。</li><li><strong>订阅数据库变更日志，再操作缓存</strong>：当一条数据发生修改时，MySQL就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。 </li></ul><h2 id="如果先删除缓存再更新数据库会怎样？"><a href="#如果先删除缓存再更新数据库会怎样？" class="headerlink" title="如果先删除缓存再更新数据库会怎样？"></a>如果先删除缓存再更新数据库会怎样？</h2><ul><li>数据库的写操作（IO操作）通常比内存操作慢得多。在A更新数据库的这段“漫长”时间里，非常容易插进来一个读请求B，把旧数据重新“种”回缓存。</li><li>解决方案：延迟双删：<ul><li>先删除缓存</li><li>更新数据库</li><li>休眠N毫秒</li><li>再次删除缓存</li></ul></li></ul><h2 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h2><ul><li><strong>缓存雪崩</strong>：当<font color="#ff0000">大量缓存数据在同一时间过期（失效）</font>或者<font color="#ff0000">Redis故障宕机</font>时，如果此时有大量的用户请求，都无法在redis中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</li><li><strong>缓存击穿</strong>：如果<font color="#ff0000">缓存中的某个热点数据过期</font>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。</li><li><strong>缓存穿透</strong>：当用户访问的数据，<font color="#ff0000">既不在缓存中，也不在数据库中</font>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增。</li></ul><h2 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h2><h3 id="针对redis服务宕机问题"><a href="#针对redis服务宕机问题" class="headerlink" title="针对redis服务宕机问题"></a>针对redis服务宕机问题</h3><ul><li><strong>redis集群</strong>：采用redis集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster和Redis Sentinel是两种最常用的Redis集群实现访问。</li><li><strong>多级缓存</strong>：设置多级缓存，例如本地缓存+Redis缓存的二级缓存组合，当Redis缓存出现问题时，还可以从本地缓存中获取到部分数据。</li><li><strong>限流与熔断</strong>：<ul><li>限流：每秒只允许N个请求通过</li><li>熔断：当检测到redis无法连接或数据库压力过大时，直接触发熔断，后续请求直接返回系统繁忙或默认值，不再去查数据库。</li></ul></li></ul><h3 id="针对集中失效问题"><a href="#针对集中失效问题" class="headerlink" title="针对集中失效问题"></a>针对集中失效问题</h3><ul><li><strong>均匀设置过期时间</strong>：如果要给缓存数据设置过期时间，应该避免大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<font color="#ff0000">给这些数据的过期时间加上一个随机数</font>，这样就保证数据不会在同一时间过期。</li><li><strong>提前预热（推荐）</strong>：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间，比如秒杀场景下的数据在秒杀结束之前不过期。</li></ul><h2 id="缓存击穿解决办法"><a href="#缓存击穿解决办法" class="headerlink" title="缓存击穿解决办法"></a>缓存击穿解决办法</h2><ul><li><strong>永不过期（不推荐）</strong>：设置热点数据永不过期或者过期时间比较长。</li><li><strong>提前预热（推荐）</strong>：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li><strong>互斥锁（看情况）</strong>：在缓存失效后，通过<font color="#ff0000">设置互斥锁确保只有一个请求去查询数据库并把数据更新到缓存</font>中。</li></ul><h2 id="缓存穿透解决办法"><a href="#缓存穿透解决办法" class="headerlink" title="缓存穿透解决办法"></a>缓存穿透解决办法</h2><ul><li><strong>非法请求的限制</strong>：在API入口处我们要判断请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li><strong>缓存空值或者默认值</strong>：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li><li><strong>布隆过滤器</strong>：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询Redis和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis自身也是支持布隆过滤器的。</li></ul><h2 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h2><ul><li>布隆过滤器由「<strong>初始值都为0的位图数组</strong>」和「<strong>N个哈希函数</strong>」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</li><li>布隆过滤器会通过3个操作完成标记：<ul><li>使用N个哈希函数分别对数据做哈希计算，<strong>得到N个哈希值</strong>；</li><li>将第一步得到的N个哈希值对位图数组的长度取模，<strong>得到每个哈希值在位图数组的对应位置</strong>；</li><li><strong>将每个哈希值在位图数组的对应位置的值设置为1</strong>。</li></ul></li><li>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要用redis？&quot;&gt;&lt;a href=&quot;#为什么要用redis？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用redis？&quot;&gt;&lt;/a&gt;为什么要用redis？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问速度更快&lt;/strong&gt;：传统数据</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://lixrangel.com/2025/12/27/java-ba-gu/redis/redis-chi-jiu-hua/"/>
    <id>http://lixrangel.com/2025/12/27/java-ba-gu/redis/redis-chi-jiu-hua/</id>
    <published>2025-12-26T16:00:00.000Z</published>
    <updated>2026-01-26T07:31:55.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h2><ul><li><strong>快照（snapshotting，RDB）</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘。</li><li><strong>只追加文件（append-only file，AOF）</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。</li><li>ROB和AOF的混合持久化。</li></ul><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><ul><li>Redis可以通过创建快照来获得存储在内存里面的数据<strong>在某个时间点上的副本</strong>。Redis创建快照之后，可以<strong>将快照复制到其他服务器</strong>从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。RDB记录的就是数据，而不是操作。</li><li>Redis提供了两个命令来生成RDB快照文件，区别在于是否在【主线程】里执行：<ul><li><code>save</code>：在主线程生成RDB文件，同步保存操作，会阻塞Redis主线程；</li><li><code>bgsave</code>：fork出一个子进程，子进程执行，不会阻塞Redis主线程，默认选项。</li></ul></li></ul><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><ul><li>与快照持久化相比，AOF持久化的实时性更好。默认情况下Redis没有开启AOF方式的持久化（Redis6.0之后已经默认是开启了），可以通过<code>appendonly</code>参数开启。</li><li>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入到<strong>AOF缓冲区</strong><code>server.aof_buf</code>中，然后再写入到AOF文件中（此时还在<strong>系统内核缓冲区</strong>未同步到磁盘），最后再根据<strong>持久化方式</strong>（fsync策略）的配置来决定何时将系统内核缓冲区的数据同步到硬盘中。（只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓冲区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了）。</li></ul><h2 id="AOF工作基本流程"><a href="#AOF工作基本流程" class="headerlink" title="AOF工作基本流程"></a>AOF工作基本流程</h2><ol><li><strong>命令追加（append）</strong>：所有的写命令会追加到AOF缓冲区中。</li><li><strong>文件写入（write）</strong>：调用<font color="#ff0000">write函数</font>（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。<blockquote><p>此时还没有同步到磁盘。</p></blockquote></li><li><strong>文件同步（fsync）</strong>：根据你在<code>redis.conf</code>文件里<code>appendfsync</code>配置的策略，Redis会在不同的时机调用<code>fsync</code>函数（系统调用）。<code>fsync</code>针对单个文件操作，对其进行强制硬盘同步（文件在内核缓冲区里的数据写到硬盘），<code>fsync</code>将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li><li><strong>文件重写（rewrite）</strong>：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当Redis重启时，可以加载AOF文件进行数据恢复。<br><img src="AOF%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="AOF工作基本流程"></li></ol><h2 id="AOF持久化方式有哪些？"><a href="#AOF持久化方式有哪些？" class="headerlink" title="AOF持久化方式有哪些？"></a>AOF持久化方式有哪些？</h2><p>三种<code>fsync</code>策略：</p><ol><li><code>appendfsync always</code>：主线程调用<code>write</code>执行写操作后，会<strong>立刻调用</strong><code>fsync</code>函数同步AOF文件（刷盘）。<strong>主线程会阻塞</strong>，直到<code>fsync</code>将数据完全刷到磁盘后才会返回。这种方式数据最安全，理论上不会有任何数据丢失。但因为每个写操作都会同步阻塞主线程，所以性能极差。</li><li><code>appendfsync everysec</code>：主线程调用<code>write</code>执行写操作后<strong>立即返回</strong>，由<strong>后台线程</strong>（<code>aof_fsync</code>线程）<strong>每秒钟</strong>调用<code>fsync</code>函数（系统调用）同步一次AOF文件。这种方式<strong>主线程的性能基本不受影响</strong>。在性能和数据安全之间做出了绝佳的平衡。不过，在Redis异常宕机时，最多可能丢失最近1秒内的数据。</li><li><code>appendfsync no</code>：主线程调用<code>write</code>执行写操作后立即返回，让<strong>操作系统决定</strong>何时进行同步，Linux下一般为30秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code>的时机由操作系统决定）。这种方式性能最好，因为避免了<code>fsync</code>的阻塞。但数据安全性最差，宕机时丢失的数据量不可控，取决于操作系统上一次同步的时间点。</li></ol><h2 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h2><ol><li><strong>Fork子进程</strong>：Redis主进程fork出一个子进程（此时利用操作系统的写时复制Copy-On-Write机制，子进程拥有父进程那一瞬间的内存数据快照）。</li><li><strong>子进程写新的AOF文件</strong>：子进程不关心旧的AOF文件，它直接遍历内存中的数据。如果内存里有<code>key1 = 10000</code>（他可能在旧的AOF文件中是10000条INCR命令），它就在新的临时AOF文件里写一条<code>SET key1 10000</code>；如果内存里有一个list，它就用一条<code>RPUSH</code>命令把里面所有元素记录下来。总结：<font color="#ff0000">用最少的命令，还原当前内存里的数据状态</font>。</li><li><strong>父进程处理新请求（AOF重写缓冲区）</strong>：在子进程重写的过程中，主进程依然在接收客户端的新写入命令。主进程会把这些新命令写入到一个专门的<font color="#ff0000">AOF重写缓冲区</font>中，防止数据丢失。</li><li><strong>合并</strong>：当子进程写完临时文件后，通知主进程。主进程把”AOF重写缓冲区”里积累的<font color="#ff0000">新命令追加到临时文件末尾</font>。</li><li><strong>替换</strong>：用这个新的、体积很小的临时文件，原子地<strong>替换掉旧的AOF文件</strong>。</li></ol><h2 id="AOF和RDB的优缺点"><a href="#AOF和RDB的优缺点" class="headerlink" title="AOF和RDB的优缺点"></a>AOF和RDB的优缺点</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li>优点：<ul><li>AOF提供了更好的数据安全性，因为它默认每接收到一个写命令就会追加到文件末尾。即使Redis服务器宕机，也只会丢失最后一次写入前的数据。</li><li>AOF支持<strong>多种同步策略</strong>，可以根据需要调整数据安全性和性能之间的平衡。</li><li>AOF文件在redis启动时可以通过<strong>重写机制优化</strong>，减少文件体积，加快恢复速度。</li></ul></li><li>缺点：<ul><li>因为记录了每一个写操作，所以<strong>AOF文件通常比RDB文件更大</strong>，消耗更多的磁盘空间。</li><li>频繁的磁盘IO操作可能会对redis的写入性能造成一定影响。</li></ul></li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul><li>优点：<ul><li>RDB文件存储的内容是<strong>经过压缩的二进制数据</strong>，<strong>文件体积小</strong>，备份和恢复的速度非常快。</li><li>RDB是在主线程之外通过fork子线程来进行的，不会阻塞服务器处理命令请求，对redis服务的性能影响较小。</li><li>使用RDB文件恢复数据，<strong>直接解析还原数据即可</strong>，不需要一条一条地执行命令，速度非常快。</li></ul></li><li>缺点：<ul><li>RDB方式在两次快照之间，如果redis服务器发生故障，这段时间的数据会丢失。</li><li>如果在RDB创建快照到恢复期间有写操作，恢复后的数据可能与故障前的数据不完全一致。</li></ul></li></ul><h2 id="两种持久化方式的使用场景"><a href="#两种持久化方式的使用场景" class="headerlink" title="两种持久化方式的使用场景"></a>两种持久化方式的使用场景</h2><ul><li>Redis保存的数据丢失一些也没什么影响的话，可以选择使用RDB。</li><li>不建议单独使用AOF，因为时不时地创建一个RDB快照可以进行数据库备份、更快的重启以及解决AOF引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启RDB和AOF持久化或者开启RDB和AOF混合持久化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis持久化方式&quot;&gt;&lt;a href=&quot;#Redis持久化方式&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化方式&quot;&gt;&lt;/a&gt;Redis持久化方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快照（snapshotting，RDB）&lt;/st</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存淘汰和过期删除</title>
    <link href="http://lixrangel.com/2025/12/26/java-ba-gu/redis/redis-huan-cun-tao-tai-he-guo-qi-shan-chu/"/>
    <id>http://lixrangel.com/2025/12/26/java-ba-gu/redis/redis-huan-cun-tao-tai-he-guo-qi-shan-chu/</id>
    <published>2025-12-25T16:00:00.000Z</published>
    <updated>2026-01-26T07:28:19.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis过期删除策略"><a href="#Redis过期删除策略" class="headerlink" title="Redis过期删除策略"></a>Redis过期删除策略</h2><ol><li><strong>惰性删除</strong>：不主动删除过期键，<font color="#ff0000">只会在取出/查询key的时候才会对数据进行过期检查</font>，如果过期则删除该key。这种方式对CPU最友好，但是可能会造成太多过期key没有被删除。</li><li><strong>定期删除</strong>：<font color="#ff0000">周期性地随机从设置了过期时间的key中抽查一批</font>，然后逐个检查这些key是否过期，过期就删除key。相比于惰性删除，定期删除对内存更友好，对CPU不太友好。</li><li>Redis选择「<strong>惰性删除+定期删除</strong>」这两种策略配合使用，以求在合理使用CPU时间和避免内存浪费之间取得平衡。<br>惰性删除的流程图：<br><img src="%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png#pic_center" alt="惰性删除流程图"><br>定期删除流程图：<br><img src="%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png#pic_center" alt="定期删除流程图"><br>定期删除参数：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ACTIVE_EXPIRE_CYCLE_FAST_DURATION</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">/* Microseconds. */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC</span> <span class="token expression"><span class="token number">25</span> </span><span class="token comment">/* Max % of CPU to use. */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">/* % of stale keys after which                                                   we do extra efforts. */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="大量key集中过期怎么办？"><a href="#大量key集中过期怎么办？" class="headerlink" title="大量key集中过期怎么办？"></a>大量key集中过期怎么办？</h2><ol><li><strong>尽量避免key集中过期</strong>：在设置键的过期时间时尽量随机一点。</li><li><strong>开启lazy free机制</strong>：修改<code>redis.conf</code>配置文件，将<code>lazyfree-lazy-expire</code>参数设置为yes，即可开启lazy free机制。开启lazy free机制后，Redis会<font color="#ff0000">在后台异步删除过期的key</font>，不会阻塞主线程的运行，从而降低对Redis性能的影响。</li></ol><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><ul><li>Redis的内存淘汰策略<strong>只有在运行内存达到了配置的最大内存阈值时才会触发</strong>，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64位操作系统下，<code>maxmemory</code>默认为0，表示不限制内存大小。32位操作系统下，默认的最大内存值是3GB。</li><li>redis提供了6种内存淘汰策略：<ul><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据（<code>server.db[i].expires</code>）中挑选最久未使用的键的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile- random</strong>：从已设置过期时间的数据（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：从所有数据（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li><li><strong>allkeys-random</strong>：从所有数据（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction（默认内存淘汰策略）</strong>：禁止驱逐数据（也就是不淘汰），当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul></li><li>4.0版本后增加以下两种：<ul><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：从所有数据（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。<blockquote><p>lru是时间，lfu是频率。</p></blockquote></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis过期删除策略&quot;&gt;&lt;a href=&quot;#Redis过期删除策略&quot; class=&quot;headerlink&quot; title=&quot;Redis过期删除策略&quot;&gt;&lt;/a&gt;Redis过期删除策略&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;：不主动删除过</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务</title>
    <link href="http://lixrangel.com/2025/12/25/java-ba-gu/redis/redis-shi-wu/"/>
    <id>http://lixrangel.com/2025/12/25/java-ba-gu/redis/redis-shi-wu/</id>
    <published>2025-12-24T16:00:00.000Z</published>
    <updated>2026-01-26T07:24:34.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何实现Redis原子性？"><a href="#如何实现Redis原子性？" class="headerlink" title="如何实现Redis原子性？"></a>如何实现Redis原子性？</h2><ul><li>redis执行一条命令的时候是具备原子性的，因为redis执行命令的时候是单线程处理的，不存在多线程安全的问题。</li><li>如果要保证2条命令的原子性的话，可以考虑用lua脚本，将多个操作写到一个lua脚本中，redis会把整个lua脚本作为一个整体执行，在执行过程中不会被其他命令打断，从而保证了lua脚本中操作的原子性。</li></ul><h2 id="除了lua有没有什么也能保证redis的原子性？"><a href="#除了lua有没有什么也能保证redis的原子性？" class="headerlink" title="除了lua有没有什么也能保证redis的原子性？"></a>除了lua有没有什么也能保证redis的原子性？</h2><ul><li>redis事务也可以保证多个操作的原子性。</li><li>如果redis事务正常执行，没有发生任何错误，那么使用 MULTI（开始事务）和 EXEC（执行事务） 配合使用，就可以保证多个操作都完成。</li><li>但是，如果事务执行发生错误了，就没办法保证原子性了。比如说 2 个操作，第一个操作执行成功了，但是第二个操作执行的时候，命令出错了，那事务并不会回滚，因为<strong>Redis 中并没有提供回滚机制</strong>。</li><li>因此，Redis 对事务原子性属性的保证情况：<ul><li>Redis 事务正常执行，可以保证原子性；</li><li>Redis 事务执行中某一个操作执行失败，不保证原子性；</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何实现Redis原子性？&quot;&gt;&lt;a href=&quot;#如何实现Redis原子性？&quot; class=&quot;headerlink&quot; title=&quot;如何实现Redis原子性？&quot;&gt;&lt;/a&gt;如何实现Redis原子性？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;redis执行一条命令的时候是具备原子性</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis线程模型</title>
    <link href="http://lixrangel.com/2025/12/24/java-ba-gu/redis/redis-xian-cheng-mo-xing/"/>
    <id>http://lixrangel.com/2025/12/24/java-ba-gu/redis/redis-xian-cheng-mo-xing/</id>
    <published>2025-12-23T16:00:00.000Z</published>
    <updated>2026-01-22T13:30:56.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h2><ul><li><strong>纯内存操作</strong>：Redis的大部分操作都<font color="#ff0000">在内存中完成</font>，并且采用了高效的数据结构，访问速度是纳秒级别，而传统的数据库频繁读写磁盘的速度是毫秒级别，两者相差数个数量级。</li><li><strong>高效的I/O模型</strong>：Redis使用单线程时间循环配合I/O多路复用技术，让<font color="#ff0000">单个线程可以同时处理多个网络连接上的I/O事件</font>（如读写），避免了多线程模型中的上下文切换和锁竞争问题。</li><li><strong>优化的内部数据结构</strong>：Redis提供多种数据类型，其内部实现<font color="#ff0000">采用高度优化的编码方式</font>，Redis会根据数据大小和类型动态选择最合适的内部编码，以在性能和空间效率之间取得最佳平衡。</li><li><strong>简洁高效的通信协议</strong>：Redis使用的是自己设计的RESP协议。该协议<font color="#ff0000">实现简单</font>、<font color="#ff0000">解析性能好</font>，并且是<font color="#ff0000">二进制安全</font>的。客户端和服务端之间通信的序列化/反序列化开销很小，有助于提升整体的交互速度。</li></ul><h2 id="Redis哪些地方使用了多线程？"><a href="#Redis哪些地方使用了多线程？" class="headerlink" title="Redis哪些地方使用了多线程？"></a>Redis哪些地方使用了多线程？</h2><ul><li>Redis单线程指的是「<strong>接收客户端请求 -&gt; 解析请求 -&gt; 进行数据读写等操作 -&gt; 发送数据给客户端</strong>」这个过程是由一个线程（主线程）来完成的。也就是Redis的主要工作（<strong>网络I/O和执行命令</strong>）是单线程来处理的。</li><li>Redis程序并不是单线程的，Redis在启动的时候，是会<strong>启动后台线程</strong>（BIO）的。Redis为「<strong>关闭文件、AOF刷盘、释放内存</strong>」这些任务创建单独的线程来处理，因为这些任务耗时，所以创建其他线程来异步处理这些任务。</li><li>为了提高网络I/O的并行度，Redis6.0对于网络I/O采用多线程来处理。但是对于命令的执行，Redis仍然使用单线程来处理。</li><li>Redis6.0版本之后，Redis在启动的时候，默认情况下会额外创建6个线程（这里的线程不包括主线程）：<ul><li><code>Redis-server</code>：Redis的主线程，主要负责执行命令；</li><li><code>bio_close_file</code>、<code>bio_aof_fsync</code>、<code>bio_lazy_free</code>：三个后台线程，分别异步处理「关闭文件任务」、「AOF刷盘任务」、「释放内存任务」；</li><li><code>io_thd_1</code>、<code>io_thd_2</code>、<code>io_thd_3</code>：三个I/O线程，io_threads默认是4，所以会启动3（4 - 1）个I/O多线程，用来分担Redis网络I/O的压力。</li></ul></li></ul><h2 id="Redis单线程模型？"><a href="#Redis单线程模型？" class="headerlink" title="Redis单线程模型？"></a>Redis单线程模型？</h2><ul><li>Redis基于 Reactor 模式设计开发了一套高效的事件处理模型，这套事件处理模型对应的是Redis中的<strong>文件事件处理器</strong>（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说Redis是单线程模型。</li><li>文件事件处理器（file event handler）主要是包含4个部分：<ul><li>多个socket（客户端连接）；</li><li>IO多路复用程序（支持多个客户端连接的关键）；</li><li>文件事件分派器（将socket关联到相应的事件处理器）；</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。<br><img src="%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="文件事件处理器"></li></ul></li></ul><h2 id="Redis怎么实现的IO多路复用？"><a href="#Redis怎么实现的IO多路复用？" class="headerlink" title="Redis怎么实现的IO多路复用？"></a>Redis怎么实现的IO多路复用？</h2><ul><li>Redis是跑在「单线程」中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以I/O操作在一般情况下往往不能直接返回，这会导致某一文件的I/O阻塞掉，致整个进程无法对其他客户提供服务。而I/O多路复用就是为了解决这个问题而出现的。为了<strong>让单线程（进程）的服务端应用同时处理多个客户端的事件</strong>，Redis采用了IO多路复用机制。</li><li>这里“多路”指的是<strong>多个网络连接客户端</strong>，“复用”指的是<strong>复用同一个线程</strong>（单进程）。I/O多路复用其实是使用一个线程来检查多个socket的就绪状态，在单个线程中通过记录跟踪每一个socket（I/O流）的状态来管理处理多个I/O流。如下图是Redis的I/O多路复用模型：<br><img src="Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="Redis的IO多路复用模型"></li><li>一个socket客户端与服务端连接时，会生成对应的一个<strong>套接字描述符</strong>（其实就是一个整数，是这个连接在操作系统中的一个索引），每一个socket网络连接其实都对应一个文件描述符。</li><li>多个客户端与服务端连接时，Redis使用I/O多路复用程序<strong>将客户端socket对应的FD注册到监听列表</strong>中。当客户端执行read、write等操作命令时，数据到达内核缓冲区，epoll检测到该FD状态变为“可读”，便会生成一个事件通知Redis。Redis拿到时间后，调用对应的处理函数读取并解析命令。<blockquote><p>IO多路复用程序是一个封装层，封装了操作系统底层的多路复用函数（如Linux的epoll、macOS的kqueue或旧的select。</p></blockquote></li><li>文件事件处理器使用I/O多路复用模块同时监控多个文件描述符（FD）的读写情况，当accept、read、write和close文件事件产生时，文件事件处理器就会回调FD绑定的事件处理器进行处理相关命令操作。</li><li>例如：以Redis的IO多路复用程序epoll函数为例。多个客户端连接服务端时，Redis会将客户端socket对应的FD（文件描述符）注册进epoll，然后epoll同时监听多个文件描述符（FD）是否有数据到来，如果有数据来了就通知事件处理器赶紧处理，这样就不会存在服务端一直等待某个客户端给数据的情形。</li><li>整个<strong>文件事件处理器是在单线程上运行的</strong>，但是通过I/O多路复用模块的引入，实现了同时对多个FD读写的监控，当其中一个client端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现I/O阻塞的问题，提高了网络通信的性能。</li></ul><table><thead><tr><th>状态</th><th>过程</th><th>线程状态</th></tr></thead><tbody><tr><td>等待事件</td><td>Redis主线程调用epoll_wait()，将自己挂起。</td><td>阻塞（但同时高效监听所有FD）</td></tr><tr><td>事件就绪</td><td>内核通知epoll，有N个FD就绪。epoll将线程唤醒。</td><td>运行</td></tr><tr><td>处理数据</td><td>主线程遍历这N个就绪FD，执行read和命令处理。</td><td>运行</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis为什么快？&quot;&gt;&lt;a href=&quot;#Redis为什么快？&quot; class=&quot;headerlink&quot; title=&quot;Redis为什么快？&quot;&gt;&lt;/a&gt;Redis为什么快？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;纯内存操作&lt;/strong&gt;：Redis的大部分</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构</title>
    <link href="http://lixrangel.com/2025/12/23/java-ba-gu/redis/redis-shu-ju-jie-gou/"/>
    <id>http://lixrangel.com/2025/12/23/java-ba-gu/redis/redis-shu-ju-jie-gou/</id>
    <published>2025-12-22T16:00:00.000Z</published>
    <updated>2026-01-21T12:29:42.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><table><thead><tr><th>结构类型</th><th>底层数据结构</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>简单动态字符串（SDS）</td><td>可以是字符串、整型或浮点数</td><td>对整个字符串或字符串的一部份进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>LinkedList、ZipList、QuickList</td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>Dict、ZipList</td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法：是否存在、添加、获取、删除；还包含计算交集、并集、差集等；</td></tr><tr><td><strong>Hash散列</strong></td><td>Dict、ZipList</td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>ZipList、SkipList</td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素。</td></tr></tbody></table><ul><li>五种数据类型的应用场景：<ul><li><strong>String类型</strong>：缓存对象、常规计数、分布式锁、共享session信息等；</li><li><strong>List类型</strong>：消息队列（问题：1. 生产者需要自行实现全局唯一ID；2. 不能以消费组形式消费数据）等。</li><li><strong>Hash类型</strong>：缓存对象、购物车等；</li><li><strong>Set类型</strong>：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li><strong>Zset类型</strong>：排序场景，比如排行榜、电话和姓名排序等。</li></ul></li><li>后续版本支持的四种数据类型，它们的应用场景：<ul><li><strong>BitMap（2.2版新增）</strong>：二值状态统计的场景，比如签到、判断用户登录状态、连续签到用户总数等；</li><li><strong>HyperLogLog（2.8版新增）</strong>：海量数据基数统计的场景，比如百万级网页UV计数等；</li><li><strong>GEO（3.2版新增）</strong>：存储地理位置信息的场景，比如滴滴叫车；</li><li><strong>Stream（5.0版新增）</strong>：消息队列，相比于基于List类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组的形式消费数据。<br><img src="redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redis数据结构"></li></ul></li></ul><h2 id="Zset底层是怎么实现的？"><a href="#Zset底层是怎么实现的？" class="headerlink" title="Zset底层是怎么实现的？"></a>Zset底层是怎么实现的？</h2><p>Zset类型的底层数据结构是由压缩列表或跳表实现的：</p><ul><li>如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用压缩列表作为Zset类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis会使用跳表作为Zset类型的底层数据结构；<br>在Redis 7.0中，压缩列表数据结构已经废弃了，交由listpack数据结构来实现了。</li></ul><h2 id="跳表是怎么实现的？"><a href="#跳表是怎么实现的？" class="headerlink" title="跳表是怎么实现的？"></a>跳表是怎么实现的？</h2><ul><li>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是$O(N)$，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种【多层】的有序链表，这样的好处是能<strong>快速定位数据</strong>。<br><img src="%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="跳表数据结构"></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct zskiplistNode &#123;    &#x2F;&#x2F;Zset 对象的元素值    sds ele;    &#x2F;&#x2F;元素权重值    double score;    &#x2F;&#x2F;后向指针    struct zskiplistNode *backward;      &#x2F;&#x2F;节点的level数组，保存每层上的前向指针和跨度    struct zskiplistLevel &#123;        struct zskiplistNode *forward;        unsigned long span;    &#125; level[];&#125; zskiplistNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Zset 对象要同时保存【<strong>元素</strong>】和【<strong>元素的权重</strong>】，对应到跳表节点结构里就是SDS类型的ele变量和double类型的score变量。每个跳表节点都有一个后向指针（<code>struct zskiplistNode *backward</code>），指向前一个节点，目的是为了<font color="#ff0000">方便从跳表的尾节点开始访问节点</font>，这样倒序查找时很方便。</li><li>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<code>zskiplistLevel</code>结构体类型的level数组。</li><li>level数组中的每一个元素代表跳表的一层，也就是由zskiplistLevel结构体表示，比如<code>level[0]</code>就表示第一层，<code>level[1]</code>就表示第二层。zskiplistLevel结构体里定义了【<strong>指向下一跳表节点的指针</strong>】和【<strong>跨度</strong>】，跨度是用来记录两个节点之间的距离。<br><img src="%E8%B7%B3%E8%A1%A8%E8%B7%A8%E5%BA%A6.png" alt="跳表跨度"></li><li>Redis跳表在创建节点的时候，随机生成每个节点的层数，并没有严格维持相邻两层的节点数量比例为2:1的情况。</li><li>具体的做法是，跳表在创建节点的时候，会生成范围为$[0-1]$的一个随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加1层，然后继续生成下一个随机数，直到随机数的结果大于0.25结束，最终确定该节点的层数。（【跳表是怎么设置层高的？】的答案）。</li><li>这样的做法相当于**每增加一层的概率不超过25%**，层数越高，概率越多，层高最大限制是64。在创建跳表头节点时，会直接创建64层高的头节点。</li></ul><h2 id="面试——跳表"><a href="#面试——跳表" class="headerlink" title="面试——跳表"></a>面试——跳表</h2><ul><li>跳表（SkipList）本质上是一种可以通过“<strong>多级索引</strong>”进行快速查找的有序链表。它利用空间换时间的思想，把普通链表的查找复杂度从$O(N)$降到了$O(\log N)$，性能可以媲美红黑树，但实现更简单。</li><li>它的结构可以分为两部分：<ul><li><strong>最底层（L0）</strong>：是一个包含所有数据的<font color="#ff0000">有序双向链表</font>。</li><li><strong>上层索引（L1, L2,…）</strong>：是在底层链表的基础上，<font color="#ff0000">每隔一段距离提取一个节点作为索引</font>。层级越高，节点越稀疏。</li></ul></li><li>查找时，从最高层索引开始，像“坐电梯”一样，发现目标太大就往右跳，发现目标太小就往下一层沉，直到找到数据。</li><li>每个节点的层高是由$[0-1]$的随机数决定的，如果小于0.25，就增加一层；如果大于0.25，就停止。</li></ul><h2 id="Redis为什么使用跳表而不是B-树？"><a href="#Redis为什么使用跳表而不是B-树？" class="headerlink" title="Redis为什么使用跳表而不是B+树？"></a>Redis为什么使用跳表而不是B+树？</h2><ol><li>内存 vs. 磁盘的设计初衷：<ol><li><strong>B+数是为磁盘I/O优化的</strong>：B+树的设计核心是降低树的的高度，从而减少磁盘I/O次数。</li><li><strong>Redis是纯内存操作</strong>：在内存中，没有磁盘I/O的瓶颈。内存中指针跳转的速度非常快。跳表虽然比B+树高（层数多），但在内存中多几次指针跳转的开销非常小。</li></ol></li><li>实现复杂度与代码维护：<ol><li>跳表（Skip List）：本质上是“<strong>多层链表</strong>”，其插入、删除逻辑主要是修改指针，代码实现非常简洁。</li><li>B+树：插入和删除可能引发节点的分裂和合并，甚至需要<strong>对整棵树进行重平衡</strong>。实现一个健壮、高效的B+树非常复杂，代码量大且难以调试。</li></ol></li><li>写入性能与重平衡代价：<ol><li>B+树的写入抖动：当插入数据导致页分裂时，可能需要移动大量数据或改变树结构，这会产生性能抖动。</li><li>跳表的局限性：跳表的插入和删除操作是局部的。插入一个节点只需要修改前后节点的指针，并根据概率随机生成层高。它不需要像红黑树或B+树那样进行全局的旋转或复杂的结构调整。</li></ol></li></ol><h2 id="String是用什么存储的？为什么不用C语言中的字符串？"><a href="#String是用什么存储的？为什么不用C语言中的字符串？" class="headerlink" title="String是用什么存储的？为什么不用C语言中的字符串？"></a>String是用什么存储的？为什么不用C语言中的字符串？</h2><p>Redis的String字符串是用SDS数据结构存储的。<br><img src="SDS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="SDS数据结构"></p><ul><li><code>len</code>，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要$O(1)$。</li><li><code>alloc</code>，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过<code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><code>flags</code>，用来表示不同类型的SDS。一共设计了5种类型，分别是<code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code>、<code>sdshdr64</code>。</li><li><code>buf[]</code>，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。</li></ul><h3 id="相比于C语言的优势："><a href="#相比于C语言的优势：" class="headerlink" title="相比于C语言的优势："></a>相比于C语言的优势：</h3><ul><li><strong>$O(1)$复杂度获取字符串的长度</strong>。C语言需要遍历，时间复杂度是$O(N)$。</li><li><strong>二进制安全</strong>。因为SDS不需要用”\0”字符来标识字符串结尾了，而是有个专门的len成员变量来记录长度，所以可以存储包含”\0”的数据。但是SDS为了兼容部分C语言标准库的函数，SDS字符串结尾还是会加上”\0”字符。而C语言会通过”\0”来判断字符串的结束，所以不能存储任何带有”\0”的字符串。</li><li><strong>不会发生缓冲区溢出</strong>。Redis的SDS结构里引入了<code>alloc</code>和<code>len</code>成员变量，这样SDS API通过<code>alloc - len</code>计算，可以算出剩余可用的空间大小，这样在对字符串做修改的时候，就可以由程序内部判断缓冲区大小是否足够用。当判断出缓冲区大小不够用时，Redis会自动将扩大SDS的空间大小，以满足修改所需的大小。而C语言需要开发者来保证缓冲区大小。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis底层数据结构&quot;&gt;&lt;a href=&quot;#Redis底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis底层数据结构&quot;&gt;&lt;/a&gt;Redis底层数据结构&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结构类型&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    
    <category term="八股" scheme="http://lixrangel.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="http://lixrangel.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://lixrangel.com/2025/10/25/shua-ti/hua-dong-chuang-kou/"/>
    <id>http://lixrangel.com/2025/10/25/shua-ti/hua-dong-chuang-kou/</id>
    <published>2025-10-24T16:00:00.000Z</published>
    <updated>2026-01-13T12:17:28.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><img src="%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.svg" alt="无重复字符的最长子串"></p><ul><li>pre存储上一个无重复子串的第一个位置</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><img src="%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.svg" alt="找到字符串中所有字母异位词"></p><ul><li><code>i</code>作为外循环，<code>j</code>每次通过<code>i - n + 1</code>计算</li><li>每次都先更新charS，如果<code>j &lt; 0</code>，continue</li><li>循环结束移除charS中的<code>j</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;%E6%97%A0%E9%87%8D%E5%A4%8D%</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="http://lixrangel.com/2025/10/24/shua-ti/shuang-zhi-zhen/"/>
    <id>http://lixrangel.com/2025/10/24/shua-ti/shuang-zhi-zhen/</id>
    <published>2025-10-23T16:00:00.000Z</published>
    <updated>2026-01-13T12:11:54.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a><br><img src="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.svg" alt="盛最多水的容器"></p><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a><br><img src="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.svg" alt="三数之和"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;盛最多水的容器&quot;&gt;&lt;a href=&quot;#盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;盛最多水的容器&quot;&gt;&lt;/a&gt;盛最多水的容器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/container-wi</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="http://lixrangel.com/2025/10/23/shua-ti/ha-xi/"/>
    <id>http://lixrangel.com/2025/10/23/shua-ti/ha-xi/</id>
    <published>2025-10-23T07:27:10.000Z</published>
    <updated>2026-01-13T12:12:07.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a><br><img src="%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.svg" alt="字母异位词分组"></p><ul><li><code>Map&lt;String, List&lt;String&gt;&gt;</code>存储，key排序后的字符串，value是原始真实的字符串</li><li>返回<code>new ArrayList&lt;&gt;(map.values())</code></li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a><br><img src="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.svg" alt="最长连续序列"></p><ul><li>用一个set存储不重复的nums数组；</li><li>遍历set<ul><li>如果set中存在x-1，说明这不是一个连续子数组的最小值；</li><li>如果不存在，说明这是一个连续子数组的最小值，y=x+1，然后不断循环，如果set中存在，y++；</li><li>循环结束后，更新res</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;字母异位词分组&quot;&gt;&lt;/a&gt;字母异位词分组&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagra</summary>
      
    
    
    
    
    <category term="算法" scheme="http://lixrangel.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://lixrangel.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 8.10安装教程（macOS版）</title>
    <link href="http://lixrangel.com/2025/08/20/elasticsearch/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/"/>
    <id>http://lixrangel.com/2025/08/20/elasticsearch/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/</id>
    <published>2025-08-19T16:00:00.000Z</published>
    <updated>2026-01-14T09:03:03.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从Elasticsearch 8.x开始，官方不再通过Homebrew提供安装包。</p></blockquote><h2 id="1-安装ES"><a href="#1-安装ES" class="headerlink" title="1. 安装ES"></a>1. 安装ES</h2><h3 id="1-1-下载Elasticsearch"><a href="#1-1-下载Elasticsearch" class="headerlink" title="1.1 下载Elasticsearch"></a>1.1 下载Elasticsearch</h3><ul><li>访问<a href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch官方下载页面</a>，选择 8.10.0 版本并下载。</li></ul><h3 id="1-2-解压文件"><a href="#1-2-解压文件" class="headerlink" title="1.2 解压文件"></a>1.2 解压文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-xzf</span> elasticsearch-8.10.0-darwin-x86_64.tar.gz <span class="token builtin class-name">cd</span> elasticsearch-8.10.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-启动es"><a href="#1-3-启动es" class="headerlink" title="1.3 启动es"></a>1.3 启动es</h3><ul><li>可以直接进入到 bin 目录，然后执行 <code>./elasticsearch</code> 启动 ES。</li><li>默认情况下，ES 默认是自动配置堆大小的，也就是没有设置固定的内存限制，所以 ES 会根据系统可用内存自动分配，有的时候内存会飙升，可以通过下面的命令运行：<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token key attr-name">ES_JAVA_OPTS</span><span class="token punctuation">=</span><span class="token value attr-value">"-Xms5g -Xmx5g" ./bin/elasticsearch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>ES 8.10.0 需要 JDK17 版本</p></blockquote></li></ul><h2 id="2-ES安全功能解除方法"><a href="#2-ES安全功能解除方法" class="headerlink" title="2. ES安全功能解除方法"></a>2. ES安全功能解除方法</h2><ul><li>es的安全功能包括：<ul><li>HTTPS：所有通信默认使用HTTPS。</li><li>身份验证：需要用户名和密码才能访问es。</li><li>证书生成：安装时会自动生成 TLS/SSL 证书。</li></ul></li></ul><h3 id="2-1-方法一：使用HTTPS访问-ES"><a href="#2-1-方法一：使用HTTPS访问-ES" class="headerlink" title="2.1 方法一：使用HTTPS访问 ES"></a>2.1 方法一：使用HTTPS访问 ES</h3><h4 id="2-1-1-找到生成的证书"><a href="#2-1-1-找到生成的证书" class="headerlink" title="2.1.1 找到生成的证书"></a>2.1.1 找到生成的证书</h4><ul><li>CA证书路径：通常位于<code>elasticsearch-8.10.0/config/certs/http_ca.crt</code></li><li>用户名和密码：默认用户是elastic，密码会在启动时生成。<pre class="line-numbers language-none"><code class="language-none">✅ Elasticsearch security features have been automatically configured!✅ Authentication is enabled and cluster connections are encrypted.ℹ️  Password for the **elastic** user (reset with &#96;bin&#x2F;elasticsearch-reset-password -u elastic&#96;):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果忘记了密码，可以通过以下命令重置：<br><code>./bin/elasticsearch-reset-password -u elastic</code></p></blockquote></li></ul><h4 id="2-1-2-使用HTTPS访问"><a href="#2-1-2-使用HTTPS访问" class="headerlink" title="2.1.2 使用HTTPS访问"></a>2.1.2 使用HTTPS访问</h4><ul><li>回到解压目录（不是bin目录），运行以下命令，指定CA证书并使用HTTPS协议：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">--cacert</span> config/certs/http_ca.crt <span class="token parameter variable">-X</span> GET <span class="token string">"https://localhost:9201"</span> <span class="token parameter variable">-u</span> elastic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里我的9200端口一直显示被占用，所以我换了9201端口。</p></blockquote></li><li>系统会提示输入密码，输入elastic用户的密码后即可访问。</li></ul><h3 id="2-2-访问二：禁用HTTPS和安全功能"><a href="#2-2-访问二：禁用HTTPS和安全功能" class="headerlink" title="2.2 访问二：禁用HTTPS和安全功能"></a>2.2 访问二：禁用HTTPS和安全功能</h3><h4 id="2-2-1-修改配置文件"><a href="#2-2-1-修改配置文件" class="headerlink" title="2.2.1 修改配置文件"></a>2.2.1 修改配置文件</h4><ul><li>编辑 config/elasticsearch.yml 文件，把这两个配置项修改为 false。<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">xpack.security.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token key atrule">xpack.security.http.ssl.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="2-2-2-重启es"><a href="#2-2-2-重启es" class="headerlink" title="2.2.2 重启es"></a>2.2.2 重启es</h4><ul><li>重启es：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./bin/elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="2-2-3-使用HTTP访问"><a href="#2-2-3-使用HTTP访问" class="headerlink" title="2.2.3 使用HTTP访问"></a>2.2.3 使用HTTP访问</h4><ul><li>现在可以通过HTTP协议访问es：<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">curl <span class="token operator">-</span>X GET <span class="token string">"http://localhost:9201"</span> <span class="token operator">-</span>u 用户名:你的密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="http%E8%AE%BF%E9%97%AEes.png" alt="http访问es"><blockquote><p>禁用安全功能仅适用于开发环境，生产环境中不建议这样做。<br>如果你在Docker中运行es，请确保将 xpack.security.enabled 设置为 false。</p></blockquote></li></ul><h2 id="3-ES安装IK分词器插件"><a href="#3-ES安装IK分词器插件" class="headerlink" title="3. ES安装IK分词器插件"></a>3. ES安装IK分词器插件</h2><ul><li>IK 分词器是阿里开源的一个中文分词工具，主要用于全文检索和文本分析：<a href="https://github.com/infinilabs/analysis-ik">IK分词器</a></li><li>可以通过命令行直接安装：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./bin/elasticsearch-plugin <span class="token function">install</span> https://get.infini.cloud/elasticsearch/analysis-ik/8.10.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>如果失败的话，使用这个链接下载：<a href="https://release.infinilabs.com/analysis-ik/stable/">IK分词器下载</a><blockquote><p>下载版本必须和es版本相同</p></blockquote></li><li>下载后使用以下命令安装本地插件：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./bin/elasticsearch-plugin <span class="token function">install</span> file:YOUR_PATH/elasticsearch-analysis-ik-8.10.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从Elasticsearch 8.x开始，官方不再通过Homebrew提供安装包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-安装ES&quot;&gt;&lt;a href=&quot;#1-安装ES&quot; class=&quot;headerlink&quot; title=&quot;1. 安</summary>
      
    
    
    
    
    <category term="es" scheme="http://lixrangel.com/tags/es/"/>
    
    <category term="agent" scheme="http://lixrangel.com/tags/agent/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="http://lixrangel.com/2025/03/13/java-ba-gu/ji-he/concurrenthashmap-yuan-ma-fen-xi/"/>
    <id>http://lixrangel.com/2025/03/13/java-ba-gu/ji-he/concurrenthashmap-yuan-ma-fen-xi/</id>
    <published>2025-03-12T16:00:00.000Z</published>
    <updated>2026-01-28T08:37:33.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ConcurrentHashMap-1-7"><a href="#1-ConcurrentHashMap-1-7" class="headerlink" title="1. ConcurrentHashMap 1.7"></a>1. ConcurrentHashMap 1.7</h2><h3 id="1-1-存储结构"><a href="#1-1-存储结构" class="headerlink" title="1.1 存储结构"></a>1.1 存储结构</h3><p><img src="ConcurrentHashMap7.svg" alt="ConcorrentHashMap1.7 存储结构"></p><ul><li><code>ConcurrentHashMap</code> 由很多个 <code>Segment</code> 组成，每一个 <code>Segment</code> 是一个类似于<code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦初始化就不能改变，默认 <code>Segment</code> 的个数是16个，也就意味着 <code>ConcurrentHashMap</code> 默认支持最多16个线程并发。</li></ul><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16). */</span><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_CONCURRENCY_LEVEL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><ul><li>无参构造中调用了有参构造，传入了三个默认参数：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 默认初始化容量 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment">/** * 默认负载因子 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment">/** * 默认并发级别 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CONCURRENCY_LEVEL</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>有参构造的内部实现：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span><span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 参数校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">></span> <span class="token constant">MAX_SEGMENTS</span><span class="token punctuation">)</span>        concurrencyLevel <span class="token operator">=</span> <span class="token constant">MAX_SEGMENTS</span><span class="token punctuation">;</span>    <span class="token comment">// Find power-of-two sizes best matching arguments</span>    <span class="token comment">// 2的多少次方</span>    <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>sshift<span class="token punctuation">;</span>        ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 记录段偏移量</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span>    <span class="token comment">// 记录段掩码</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 设置容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>    <span class="token comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span>        <span class="token operator">++</span>c<span class="token punctuation">;</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token constant">MIN_SEGMENT_TABLE_CAPACITY</span><span class="token punctuation">;</span>    <span class="token comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>        cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// create segments and segments[0]</span>    <span class="token comment">// 创建 Segment 数组，设置 segments[0]</span>    <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> s0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token constant">SBASE</span><span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ordered write of segments[0]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>源码解读：<ul><li>首先校验参数是否合法，如果并发级别<code>concurrencyLevel</code>大于65536，就重置为65536，默认为16；</li><li>计算<code>segments</code>数组的大小<code>ssize</code>。<code>segments</code>数组的长度必须是2的N次方，因此通过循环找到大于等于<code>concurrencyLevel</code>的最小的2的幂；</li><li>计算段偏移量和段掩码。这两个参数用于定位key属于哪个<code>segment</code>：<ul><li><code>segmentShift</code>：key 的 hash 值是 32 位的。<code>ConcurrentHashMap</code> 使用 hash 值的<strong>高位</strong>来定位 Segment。这里 <code>32 - sshift</code> 算出的是需要向右移动多少位才能取到高位。</li><li><code>segmentMask</code>：掩码，用于取模运算（位运算 <code>&amp;</code>）。</li><li>定位公式：<code>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask</code></li><li><img src="segmentShift.svg" alt="segmentShift"></li></ul></li><li>计算每个<code>segment</code>内部的容量<code>cap</code>。<code>initialCapacity</code> 是总容量，这里把它平均分配给 <code>ssize</code> 个 Segment。<code>cap</code>是每个 Segment 内部 <code>HashEntry[]</code> 数组的大小。它也必须是 2 的幂，且至少为 2。</li><li>初始化<code>Segment</code>数组与第一个<code>Segment</code>。构造函数中<strong>只初始化了 <code>segments[0]</code><strong>。其他的 <code>segments[1]</code> 到 <code>segments[n]</code> 此时都是 <code>null</code>。这是为了节省内存。当需要访问其他 Segment 时，会以 <code>s0</code> 为原型（包含相同的容量、负载因子）进行创建（这被称为</strong>原型模式</strong>的一种应用）。</li></ul></li></ul><h3 id="1-3-put方法"><a href="#1-3-put方法" class="headerlink" title="1.3 put方法"></a>1.3 put方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Maps the specified key to the specified value in this table. * Neither the key nor the value can be null. * * &lt;p> The value can be retrieved by calling the &lt;tt>get&lt;/tt> method * with a key that is equal to the original key. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt>key&lt;/tt>, or *         &lt;tt>null&lt;/tt> if there was no mapping for &lt;tt>key&lt;/tt> * @throws NullPointerException if the specified key or value is null */</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span>    <span class="token comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span>getObject          <span class="token comment">// nonvolatile; recheck</span>         <span class="token punctuation">(</span>segments<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;&lt;</span> <span class="token constant">SSHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">SBASE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">//  in ensureSegment</span>        <span class="token comment">// 如果查找到的 Segment 为空，初始化</span>        s <span class="token operator">=</span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present. * * @param k the index * @return the segment */</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>    <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token constant">SSHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">SBASE</span><span class="token punctuation">;</span> <span class="token comment">// raw offset，下标k在内存里的确切位置</span>    <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> seg<span class="token punctuation">;</span>    <span class="token comment">// 判断 u 位置的 Segment 是否为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> proto <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// use segment 0 as prototype</span>        <span class="token comment">// 获取0号 segment 里的 HashEntry&lt;K,V> 初始化长度</span>        <span class="token keyword">int</span> cap <span class="token operator">=</span> proto<span class="token punctuation">.</span>table<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span>        <span class="token keyword">float</span> lf <span class="token operator">=</span> proto<span class="token punctuation">.</span>loadFactor<span class="token punctuation">;</span>        <span class="token comment">// 计算扩容阀值</span>        <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> lf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建一个 cap 容量的 HashEntry 数组</span>        <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// recheck</span>            <span class="token comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span>            <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>lf<span class="token punctuation">,</span> threshold<span class="token punctuation">,</span> tab<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 自旋检查 u 位置的 Segment 是否为null</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 使用CAS 赋值，只会成功一次</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> seg <span class="token operator">=</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> seg<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过计算得到<code>segment</code>数组的下标<code>j</code>。</li><li>通过<code>j</code>计算这个位置在内存中的确切位置，如果这个位置的<code>segment</code>为空，则初始化这个<code>segment</code>——<code>s = ensureSegment(j)</code>：<ul><li>检查这个位置是不是的<code>Segment</code>是不是真的为null，因为是并发的，有可能别的线程已经初始化过了。</li><li>如果为null的话继续初始化，使用<code>Segment[0]</code>的容量和负载因子创建一个<code>HashEntry</code>数组。</li><li>再次检查这个位置的<code>Segment</code>是否为null，还是并发的问题。</li><li>如果真的为null，使用创建的<code>HashEntry</code>数组初始化这个<code>Segment</code>。</li><li>自旋（<code>UNSAFE.compareAndSwapObject</code> )判断这个位置的<code>Segment</code>是否为null，使用CAS在这个位置赋值为<code>Segment</code>。</li></ul></li><li>put插入key，value：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span>    <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">V</span> oldValue<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment">// 计算要put的数据位置</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span>        <span class="token comment">// CAS 获取 index 坐标的值</span>        <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first <span class="token operator">=</span> <span class="token function">entryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span>                <span class="token class-name">K</span> k<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                    <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> c <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> threshold <span class="token operator">&amp;&amp;</span> tab<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>                    <span class="token function">rehash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span>                    <span class="token function">setEntryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                count <span class="token operator">=</span> c<span class="token punctuation">;</span>                oldValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>因为<code>Segment</code>继承了<code>ReentrantLock</code>，所以<code>Segment</code>内部可以使用<code>tryLock()</code>很方便的获取锁，获取不到的话使用<code>sacnAndLockForPut</code>方法继续获取。</li><li>计算数据要放入的位置index，然后获取这个位置上的<code>HashEntry</code>。</li><li>如果这个位置上的<code>HashEntry</code>不存在：<ul><li>如果当前容量大于扩容阈值并小于最大容量，则进行扩容；</li><li>否则直接头插法插入。</li></ul></li><li>如果这个位置上的<code>HashEntry</code>存在：<ul><li>判断链表当前元素的key和hash值是否和要put的key和hash值一致，如果一致的话则替换值；</li><li>如果不一致的话就获取链表的下一个节点直到发现相同的，就进行值替换。</li></ul></li></ul><h3 id="1-4-扩容-rehash-方法"><a href="#1-4-扩容-rehash-方法" class="headerlink" title="1.4 扩容 rehash 方法"></a>1.4 扩容 rehash 方法</h3><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment">// 老容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 新容量，扩大两倍</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 新的扩容阀值</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建新的数组</span>    <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span>    <span class="token keyword">int</span> sizeMask <span class="token operator">=</span> newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldCapacity <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 遍历老数组</span>        <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> oldTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 计算新的位置，新的位置只可能是不变或者是老的位置+老的容量。</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token comment">//  Single node on list</span>                <span class="token comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span>                newTable<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Reuse consecutive sequence at same slot</span>                <span class="token comment">// 如果是链表了</span>                <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lastRun <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">int</span> lastIdx <span class="token operator">=</span> idx<span class="token punctuation">;</span>                <span class="token comment">// 新的位置只可能是不变或者是老的位置+老的容量。</span>                <span class="token comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last <span class="token operator">=</span> next<span class="token punctuation">;</span> last <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> last <span class="token operator">=</span> last<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> last<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> lastIdx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        lastIdx <span class="token operator">=</span> k<span class="token punctuation">;</span>                        lastRun <span class="token operator">=</span> last<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span>                newTable<span class="token punctuation">[</span>lastIdx<span class="token punctuation">]</span> <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                <span class="token comment">// Clone remaining nodes</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> e<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 遍历剩余元素，头插法到指定 k 位置。</span>                    <span class="token class-name">V</span> v <span class="token operator">=</span> p<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> h <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                    <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n <span class="token operator">=</span> newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> v<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 头插法插入新的节点</span>    <span class="token keyword">int</span> nodeIndex <span class="token operator">=</span> node<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span> <span class="token comment">// add the new node</span>    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-ConcurrentHashMap-1-8"><a href="#2-ConcurrentHashMap-1-8" class="headerlink" title="2. ConcurrentHashMap 1.8"></a>2. ConcurrentHashMap 1.8</h2><h3 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h3><p><img src="ConcurrentHashMap8.svg" alt="ConcurrentHashMap1.8 存储结构"></p><h3 id="2-2-初始化-initTable"><a href="#2-2-初始化-initTable" class="headerlink" title="2.2 初始化 initTable"></a>2.2 初始化 initTable</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Initializes table, using the size recorded in sizeCtl. */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 让出 CPU 使用权</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>核心变量<code>sizeCtl</code>的含义：<ul><li><code>0</code>：默认值，表示还未初始化</li><li><code>-1</code>：表示正在进行初始化（有线程抢到了锁）</li><li><code>&lt; -1</code>：表示正在进行扩容（高16位是邮戳，低16位是线程数）</li><li><code>&gt; 0</code>：<ul><li>如果<code>table</code>还未初始化：表示预设的初始容量（<code>initialCapacity</code>）</li><li>如果<code>table</code>已经初始化：表示下一次扩容的阈值（<code>threshold</code>，即0.75 * <code>capacity</code>）</li></ul></li></ul></li><li>while循环：<ul><li><strong>懒加载</strong>：<code>ConcurrentHashMap</code>的数组<code>table</code>不是在构造函数中创建的，而是在第一次<code>put</code>时才创建。</li><li><strong>自旋（Spin）</strong>：使用while循环，如果A线程将<code>sizeCtl</code>变为-1后去进行初始化，线程B不会放弃，而是不断尝试，也就是不断进入while循环执行<code>Thread.yield();</code>，直到线程A初始化完成返回<code>table</code>。</li></ul></li><li>两个线程如果同时尝试修改<code>sizeCtl</code>为-1，是通过CAS操作进行修改的，只有一个线程能够修改成功，这个线程就进行初始化。</li><li>双重检查：进入开始初始化前，要先判断<code>table</code>是不是还是为null，因为有可能在”判断 table == null“和“执行CAS成功“之间，已经有一个线程已经初始化完成了，并把<code>sizeCtl</code>改回了正数。</li></ul><h3 id="2-3-put方法"><a href="#2-3-put方法" class="headerlink" title="2.3 put方法"></a>2.3 put方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** Implementation for put and putIfAbsent */</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// key 和 value 不能为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// f = 目标位置元素</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span><span class="token comment">// fh 后面存放目标位置的元素 hash 值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// no lock when adding to empty bin</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 进行扩容</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 使用 synchronized 加锁加入节点</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 说明是链表</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 循环加入新的或者覆盖节点</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">K</span> ek<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                          value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 红黑树</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span>                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>根据key计算出hashcode；</li><li>判断是否需要进行初始化，也就是table是否为null；</li><li>如果key定位出的node为空，则使用CAS尝试写入，失败则自旋表示成功；</li><li>如果当前位置的<code>hashcode == MOVED == -1</code>，则需要进行扩容；</li><li>如果都不满足，则利用<code>synchronized</code>锁写入数据；</li><li>如果数量大于<code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2></li><li>Java7中<code>ConcurrentHashMap</code>使用的分段锁，因为<code>Segment</code>继承了<code>ReentrantLock</code>，也就是每一个<code>Segment</code>上同时只有一个线程可以操作，每一个<code>Segment</code>都有一个类似<code>HashMap</code>数组的结构，它可以扩容，冲突时转化成链表。但是注意：<code>Segment</code>的个数一旦初始化就不能改变！</li><li>Java8中<code>ConcurrentHashMap</code>使用的<code>synchronized</code>锁加CAS的机制。结构为Node数组+链表/红黑树，Node是类似于<code>HashEntry</code>的结构，它的冲突达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ConcurrentHashMap-1-7&quot;&gt;&lt;a href=&quot;#1-ConcurrentHashMap-1-7&quot; class=&quot;headerlink&quot; title=&quot;1. ConcurrentHashMap 1.7&quot;&gt;&lt;/a&gt;1. ConcurrentHas</summary>
      
    
    
    
    
    <category term="集合" scheme="http://lixrangel.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="Java源码" scheme="http://lixrangel.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://lixrangel.com/2025/03/12/java-ba-gu/ji-he/hashmap-yuan-ma-fen-xi/"/>
    <id>http://lixrangel.com/2025/03/12/java-ba-gu/ji-he/hashmap-yuan-ma-fen-xi/</id>
    <published>2025-03-11T16:00:00.000Z</published>
    <updated>2026-01-28T10:03:59.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JDK1-8之前"><a href="#1-JDK1-8之前" class="headerlink" title="1.  JDK1.8之前"></a>1.  JDK1.8之前</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><ul><li>数组+链表<br><img src="HashMap1.8%E4%B9%8B%E5%89%8D.svg" alt="HashMap1.8之前的数据结构"></li></ul><h3 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h3><h4 id="1-2-1-hash方法源码"><a href="#1-2-1-hash方法源码" class="headerlink" title="1.2.1 hash方法源码"></a>1.2.1 hash方法源码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// This function ensures that hashCodes that differ only by</span>    <span class="token comment">// constant multiples at each bit position have a bounded</span>    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>哈希值经过了四次扰动，性能较差</li></ul><h4 id="1-2-2-put方法"><a href="#1-2-2-put方法" class="headerlink" title="1.2.2 put方法"></a>1.2.2 put方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token constant">EMPTY_TABLE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 先遍历</span>        <span class="token class-name">Object</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再插入</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果定位到的数组位置没有元素就直接插入</li><li>如果定位到的数组位置有元素，遍历以这个元素为头节点的链表，依次和插入的key进行比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><h2 id="2-JDK1-8-之后"><a href="#2-JDK1-8-之后" class="headerlink" title="2. JDK1.8 之后"></a>2. JDK1.8 之后</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><ul><li>数组+链表+红黑树<br><img src="HashMap1.8%E4%B9%8B%E5%90%8E.svg" alt="HashMap1.8之后的数据结构"></li></ul><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="2-2-1-hash方法源码"><a href="#2-2-1-hash方法源码" class="headerlink" title="2.2.1 hash方法源码"></a>2.2.1 hash方法源码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// This function ensures that hashCodes that differ only by</span>    <span class="token comment">// constant multiples at each bit position have a bounded</span>    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>哈希值经过了四次扰动，性能较差</li></ul><h4 id="2-2-2-类的属性"><a href="#2-2-2-类的属性" class="headerlink" title="2.2.2 类的属性"></a>2.2.2 类的属性</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment">// 默认的负载因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment">// 一个包含了映射中所有键值对的集合视图</span>    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">></span><span class="token punctuation">></span></span> entrySet<span class="token punctuation">;</span>    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>loadFactor</code>负载因子<ul><li><code>loadFactor</code> 负载因子是控制数组存放数据的疏密程度，<code>loadFactor</code> 越趋近于 1，那么 数组中存放的数据也就越多，也就越密，也就是会让链表的长度增加，<code>loadFactor</code> 越小，也就是趋近于 0，数组中存放的数据也就越少，也就越稀疏。</li><li>loadFactor 的默认值为 0.75f 。loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</li><li>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li></ul></li><li><code>threshold</code>阈值<ul><li><code>threshold = capacity * loadFactor</code>，当 <code>Size&gt;threshold</code>的时候，那么就要考虑对数组的扩增了。</li></ul></li></ul><h4 id="2-2-3-Node节点类"><a href="#2-2-3-Node节点类" class="headerlink" title="2.2.3 Node节点类"></a>2.2.3 Node节点类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span><span class="token comment">//键</span>       <span class="token class-name">V</span> value<span class="token punctuation">;</span><span class="token comment">//值</span>       <span class="token comment">// 指向下一个节点</span>       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>       <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>        <span class="token comment">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-树的节点类"><a href="#2-2-4-树的节点类" class="headerlink" title="2.2.4 树的节点类"></a>2.2.4 树的节点类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 父</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>    <span class="token comment">// 左</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>   <span class="token comment">// 右</span>        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment">// 判断颜色</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 返回根节点</span>        <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-5-构造函数"><a href="#2-2-5-构造函数" class="headerlink" title="2.2.5 构造函数"></a>2.2.5 构造函数</h4><ul><li>HashMap有四个构造函数：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认构造函数。</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// all   other fields defaulted</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 包含另一个“Map”的构造函数</span> <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>     <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下面会分析到这个方法</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 指定“容量大小”的构造函数</span> <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 指定“容量大小”和“负载因子”的构造函数</span> <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>         initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>     <span class="token comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>传入的 <code>initialCapacity</code> 并不是最终的数组容量。<code>HashMap</code> 会调用 <code>tableSizeFor()</code> 将其<strong>向上取整为大于或等于该值的最小 2 的幂次方</strong>，并暂时保存到 <code>threshold</code> 字段。真正的 <code>table</code> 数组会在第一次扩容（<code>resize()</code>）时才初始化为这个大小。</li></ul><h4 id="2-2-6-put方法"><a href="#2-2-6-put方法" class="headerlink" title="2.2.6 put方法"></a>2.2.6 put方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 桶中已经存在元素（处理hash冲突）</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">// 判断插入的是否是红黑树节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不是红黑树节点则说明为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>                    <span class="token comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>                    <span class="token comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 记录e的value</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token comment">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-JDK1-8之前&quot;&gt;&lt;a href=&quot;#1-JDK1-8之前&quot; class=&quot;headerlink&quot; title=&quot;1.  JDK1.8之前&quot;&gt;&lt;/a&gt;1.  JDK1.8之前&lt;/h2&gt;&lt;h3 id=&quot;1-1-数据结构&quot;&gt;&lt;a href=&quot;#1-1-数据结构&quot;</summary>
      
    
    
    
    
    <category term="集合" scheme="http://lixrangel.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="Java源码" scheme="http://lixrangel.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>服务器连接hugging face失败</title>
    <link href="http://lixrangel.com/2024/09/16/fu-wu-qi/fu-wu-qi-lian-jie-hugging-face-shi-bai/"/>
    <id>http://lixrangel.com/2024/09/16/fu-wu-qi/fu-wu-qi-lian-jie-hugging-face-shi-bai/</id>
    <published>2024-09-15T16:00:00.000Z</published>
    <updated>2026-01-13T11:57:42.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-启用hf镜像"><a href="#1-启用hf镜像" class="headerlink" title="1. 启用hf镜像"></a>1. 启用hf镜像</h2><p><code>export HF_ENDPOINT=``https://hf-mirror.com</code></p><h2 id="2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source："><a href="#2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source：" class="headerlink" title="2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 source："></a>2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 <code>source</code>：</h2><ul><li><code>source ~/.zshrc</code> (如果你使用的是 Zsh)</li><li><code>source ~/.bashrc</code> (如果你使用的是 Bash)</li></ul><h2 id="3-检查是否启用成功"><a href="#3-检查是否启用成功" class="headerlink" title="3. 检查是否启用成功"></a>3. 检查是否启用成功</h2><p>运行以下命令验证环境变量：<br><code>echo $HF_ENDPOINT</code><br>返回下面的说明成功了：<br><img src="hf-mirror%E5%90%AF%E7%94%A8%E6%88%90%E5%8A%9F.png" alt="启用成功"></p><h2 id="4-获取模型克隆命令"><a href="#4-获取模型克隆命令" class="headerlink" title="4. 获取模型克隆命令"></a>4. 获取模型克隆命令</h2><p>打开 Hugging Face 的模型页面，点击 <strong>Clone repository</strong> 获取地址：<br><img src="hugging_face_clone.png" alt="hugging face model"></p><h2 id="5-安装工具并下载"><a href="#5-安装工具并下载" class="headerlink" title="5. 安装工具并下载"></a>5. 安装工具并下载</h2><p>首先安装官方命令行工具 <code>huggingface_hub</code>，然后使用 <code>hf download</code> 即可高速下载：<br><code>pip install -U &quot;huggingface_hub&quot;</code><br><img src="hf_download.png" alt="hf download"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-启用hf镜像&quot;&gt;&lt;a href=&quot;#1-启用hf镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 启用hf镜像&quot;&gt;&lt;/a&gt;1. 启用hf镜像&lt;/h2&gt;&lt;p&gt;&lt;code&gt;export HF_ENDPOINT=``https://hf-mirror</summary>
      
    
    
    
    
    <category term="服务器" scheme="http://lixrangel.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统与环境的安装与搭建</title>
    <link href="http://lixrangel.com/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/"/>
    <id>http://lixrangel.com/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/</id>
    <published>2022-03-19T07:27:10.000Z</published>
    <updated>2022-03-19T09:40:49.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近计算机系统基础的实验课安装搭建了Linux系统与环境，整个过程我花费了不短的时间，想在这里简单记录一下，也算是以后学习的一个参考吧。</p><h2 id="一、VMware虚拟机的下载"><a href="#一、VMware虚拟机的下载" class="headerlink" title="一、VMware虚拟机的下载"></a>一、VMware虚拟机的下载</h2><hr><h3 id="进入VM官网"><a href="#进入VM官网" class="headerlink" title="进入VM官网"></a>进入VM官网</h3><p>网址：<strong><a href="http://www.vmware.com/">www.vmware.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/1.png" class="" title="官网页面"></div><hr><h3 id="下载VMware-WorkStation-Pro"><a href="#下载VMware-WorkStation-Pro" class="headerlink" title="下载VMware WorkStation Pro"></a>下载VMware WorkStation Pro</h3><h4 id="①在工作空间中找到Workstation-Pro"><a href="#①在工作空间中找到Workstation-Pro" class="headerlink" title="①在工作空间中找到Workstation Pro"></a>①在工作空间中找到Workstation Pro</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/2.png" class="" title="点击Workstation Pro"></div><h4 id="②选择下载试用版（激活码在后面会给出）"><a href="#②选择下载试用版（激活码在后面会给出）" class="headerlink" title="②选择下载试用版（激活码在后面会给出）"></a>②选择下载试用版（激活码在后面会给出）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/3.png" class="" title="下载试用版"></div><h4 id="③选择for-Windows（这里只以Windows系统为例）"><a href="#③选择for-Windows（这里只以Windows系统为例）" class="headerlink" title="③选择for Windows（这里只以Windows系统为例）"></a>③选择for Windows（这里只以Windows系统为例）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/4.png" class="" title="选择for Windows"></div><hr><h2 id="二、VMware虚拟机的安装"><a href="#二、VMware虚拟机的安装" class="headerlink" title="二、VMware虚拟机的安装"></a>二、VMware虚拟机的安装</h2><hr><p>点击下一步完成安装即可</p><p>安装完毕后输入许可密钥（以下是网上找的几个密钥，选择哪一个都可以）：</p><p><strong>ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br> YF390-0HF8P-M81RQ-2DXQE-M2UT6<br> ZF71R-DMX85-08DQY-8YMNC-PPHV8</strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.jpg" class="" title="输入密钥"></div><p>到此，VMware的下载安装已完成，接下来完成对Ubuntu的安装。</p><hr><h2 id="三、Ubuntu的下载"><a href="#三、Ubuntu的下载" class="headerlink" title="三、Ubuntu的下载"></a>三、Ubuntu的下载</h2><hr><h3 id="进入Ubuntu官网"><a href="#进入Ubuntu官网" class="headerlink" title="进入Ubuntu官网"></a>进入Ubuntu官网</h3><p>网址：<strong><a href="http://ubuntu.com/">http://ubuntu.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.png" class="" title="官网页面"></div><hr><h3 id="下载Ubuntu"><a href="#下载Ubuntu" class="headerlink" title="下载Ubuntu"></a>下载Ubuntu</h3><p>点击【Download】</p><p>点击【20.04LTS】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/6.png" class="" title="下载Ubuntu"></div><p><strong>下载位置最好选在一个方便找到的文件夹里，后面会需要该位置</strong></p><hr><h2 id="四、Ubuntu的安装"><a href="#四、Ubuntu的安装" class="headerlink" title="四、Ubuntu的安装"></a>四、Ubuntu的安装</h2><hr><p>打开刚刚安装的VMware，点击【创建新的虚拟机】（Linux将运行在该虚拟机上）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/7.png" class="" title="创建新的虚拟机"></div><p>选择下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/8.png" class="" title="点击下一步"></div><p>选择【稍后安装操作系统】，然后点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/9.png" class="" title="点击下一步"></div><p>选择如下的操作系统和版本</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/10.png" class="" title="选择操作系统和版本"></div><p>选择虚拟机存储位置（最好不要选在系统盘）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/11.png" class="" title="选择虚拟机存储位置"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/12.png" class="" title="点击下一步"></div><p>在自定义硬件中选择合适的内存和处理器，内存给2g足够，根据电脑配置给；处理器默认；网络适配器选择NAT；把不用的打印机移除，否则后面可能会出问题。选择刚才Ubuntu文件的位置。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/13.png" class="" title="点击自定义硬件"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/14.png" class="" title="选择配置"></div><p>设置之后点击【开启虚拟机】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/15.png" class="" title="开启虚拟机"></div><p><strong>注意：这里可能会显示”此主机支持AMD-V，但AMD-V处于禁用状态“，解决办法为”重启电脑系统，进入BIOS设置，将AMD由【disabled】改为【enabled】“（我的电脑是联想小新air14，不同的电脑可能会有微小差别）</strong></p><p>等待其自行加载Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/16.png" class=""></div><p>选择简体中文并安装Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/17.png" class="" title="安装Ubuntu"></div><p>选择chinese点击继续</p><p>注意：这边可能由于屏幕太小看不到下一步，点不到继续按钮，按住alt+f7，此时鼠标变成小手，可以拖到下面。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/18.png" class=""></div><p>选择正常安装之后点击继续（此处最好把网络断开，不要勾选其他选项）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/19.png" class=""></div><p>点击安装</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/20.png" class="" title="点击现在安装"></div><p>点击继续进行下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/21.png" class="" title="点击继续"></div><p>地点直接点击继续即可，个人信息填写完毕之后继续点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/22.png" class="" title="点击继续"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/23.png" class="" title="点击继续"></div><p>等待ubuntu的自行安装即可，安装完成之后重启虚拟机。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/24.png" class="" title="重新启动"></div><p>点击账号输入密码登录</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/25.png" class="" title="登录"></div><p>安装完成之后发现虚拟机未能全屏显示</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/26.png" class="" title="未全屏显示"></div><p>在左上角的虚拟机一栏中选择安装VMware tools</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/27.png" class="" title="安装VMware tools"></div><p>右键提取到桌面并且解压，将解压文件中的vmware-tools-distrib复制到桌面</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/28.png" class="" title="提取解压"></div><p>右键，在终端打开</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/29.png" class="" title="在终端打开"></div><p>输入以下命令进行安装</p><p><strong>sudo ./vmware-install.pl（注意 . 前面有空格）</strong></p><p>在“Do you still want to proceed with this installation?”后的【no】改为【yes】，即可继续。后面都是直接按确定键即可。</p><p>至此，安装全部完成。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/cao-zuo-xi-tong/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/30.png" class="" title="安装完成"></div><hr><p>本篇文章到此就全部结束了</p><p>疫情又严重起来了，大家一定要做好防护啊！</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近计算机系统基础的实验课安装搭建了Linux系统与环境，整个过程我花费了不短的时间，想在这里简单记录一下，也算是以后学习的一个参考吧。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浏览器显示未连接互联网的解决方法</title>
    <link href="http://lixrangel.com/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/"/>
    <id>http://lixrangel.com/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/</id>
    <published>2022-03-06T09:44:29.000Z</published>
    <updated>2022-03-06T10:32:29.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天我一个舍友的浏览器总是显示未连接互联网，试了很多方法都没有解决，于是找到了我这个虽然学计算机但实际上啥也不会的舍友，在度娘的帮助下最后成功解决了。为了下一次遇到同样的问题我可以不再需要询问度娘，我在这里简单记录一下解决方案，同时也算是一个自我提升的过程吧。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><hr><p>请先检查是否真的是网络的问题，比如你的WiFi是否真的连接成功了、你的WiFi是否为可用网络。如果确定不是网络的问题，就可以进入第二步了。</p><hr><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><hr><p>如果确保网络没有问题，接下来请检查是否是浏览器的问题，可以尝试更换浏览器，建议选用Chrome、火狐等浏览器。如果也不是浏览器的问题，就可以进入第三步了。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><hr><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>打开电脑的控制面板</p><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/1.jpg" class="" title="控制面板"></div><hr><h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><ul><li>单击[<strong>网络和Internet</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/7.png" class="" title="单击[网络和Internet]"></div><hr><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><ul><li>单击[<strong>网络和共享中心</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/2.jpg" class="" title="单击[网络和共享中心]"></div><hr><h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><ul><li>单击左下角[<strong>Internet选项</strong>]</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/3.png" class="" title="单击[Internet选项]"></div><hr><h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><ul><li>选择上方的[<strong>连接</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/4.png" class="" title="选择[连接]"></div><hr><h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><ul><li>单击[<strong>局域网设置</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/5.png" class="" title="单击[局域网设置]"></div><hr><h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><ul><li>将[<strong>为LAN使用代理服务器</strong>]前的勾选取消</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/wang-luo/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/6.jpg" class="" title="取消勾选"></div><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr><p>如果通过上述步骤还是没有解决，可以自行寻求其他解决方案。由于我的技术水平十分有限，可能无法给出更多的解决方法，非常抱歉！</p><hr><p>距离我上一次更新已经过去了四个多月，主要原因还是我太懒了（惭愧），希望之后我能够督促我自己多多记录吧。</p><p>春天来啦，希望大家都能好好生活！</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天我一个舍友的浏览器总是显示未连接互联网，试了很多方法都没有解决，于是找到了我这个虽然学计算机但实际上啥也不会的舍友，在度娘的帮助下最后</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂记（二）</title>
    <link href="http://lixrangel.com/2021/10/26/za-ji/za-ji-er/"/>
    <id>http://lixrangel.com/2021/10/26/za-ji/za-ji-er/</id>
    <published>2021-10-26T10:45:24.000Z</published>
    <updated>2026-01-13T10:13:32.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h2><hr><p>距离我上一篇文章发布已经过去了三个多月，这三个多月的空余大部分原因是我太懒了，其实在写这篇文章的时候我正在上课，至于是什么课就不说了，万一老师看到了我的网站呢（我瞎说的，怎么可能）。为了督促我自己坚持记录，就在这篇里面随便聊点什么吧（由于老师的声音还不断地进入我的耳朵，所以可能逻辑不是很通顺，还请见谅）</p><ul><li><p>由于南京的疫情，我在两周前才返回校园，还上了两个星期网课，今天是线下课的第二天。也就是说，开学快两个月了，有些老师和同学长什么样我还不知道（so sad）。在我回到学校的那天，其实做了超级大的心理建设，毕竟整整三个月，无法想象那窄小的宿舍会变成什么德行。Fortunately，它并没有发霉，但是还是有一股巨大的潮味，我用了差不多一个星期才缓过来。两个星期过去，生活已经差不多步入了正轨，也是为了再次开启新的生活，我写下了这篇文章。</p></li><li><p>这个学期，我也正式进入了专业学习。由于培养方案的更改，我这学期能修的课少的可怜，还在为之后痛苦的生活嘤嘤嘤。在学习的过程中，我也深刻认识到自己的不足，好像没有太多的精力应付所有的事情，能够把基础打好都已经筋疲力竭了。在平时的生活中，我也有意识地关注一些计算机相关的信息，除了能从中收获一些知识之外，还会产生深深的焦虑，这种焦虑与我学习过程中的困难相互叠加，让我产生了较大的自我怀疑。所以这几天，我一直在尝试消化这种情绪，不知道大家有没有什么比较好的方法，欢迎与我交流，非常感谢！</p></li><li><p>在我写下这篇文章的前两天，南航实验室发生爆炸，使得我这两天的心情也比较沉重。关于这件令人心痛与惋惜的事我不做太多的评价，但是，真诚地希望，所有正在或即将为科研事业奋斗的学生们能够健康平安，在保护好自己的前提下为国家科研事业奉献。</p></li><li><p>最近我开始尝试使用Spotify，最大的体验感受为——歌词界面我好喜欢！对于我这种重度歌词爱好者来说，实在是太完美了吧，我贴个图片。</p></li></ul><div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji/za-ji-er/1.png" class="" title="搜索界面"></div> <div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji/za-ji-er/2.png" class="" title="歌词界面"></div><ul><li><p>除此之外，还有我未曾谋面的陌生人给予了我巨大的鼓励，让我对爱与勇气有了更加深刻的思考，在这里也对她们说一声谢谢。</p></li><li><p>之前说的驾考之旅记录有机会的话我也会写一下（毕竟真的太过drama了</p></li></ul><hr><p>秋天也快要过去啦，大家做好保暖措施呀</p><p>我们下一篇见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些碎碎念&quot;&gt;&lt;a href=&quot;#一些碎碎念&quot; class=&quot;headerlink&quot; title=&quot;一些碎碎念&quot;&gt;&lt;/a&gt;一些碎碎念&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;距离我上一篇文章发布已经过去了三个多月，这三个多月的空余大部分原因是我太懒了，其实在写这篇文章的时候我正在</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://lixrangel.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>杂记（一）</title>
    <link href="http://lixrangel.com/2021/08/06/za-ji/za-ji-yi/"/>
    <id>http://lixrangel.com/2021/08/06/za-ji/za-ji-yi/</id>
    <published>2021-08-06T05:33:22.000Z</published>
    <updated>2026-01-13T10:13:43.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="part1-OpenGL学习记录"><a href="#part1-OpenGL学习记录" class="headerlink" title="part1 OpenGL学习记录"></a>part1 OpenGL学习记录</h2><hr><h3 id="lesson-01"><a href="#lesson-01" class="headerlink" title="lesson 01"></a>lesson 01</h3><ul><li>在第一课配置环境这一部分我其实就遇到了困难 开始用VS2019配置 后来发现代码不一样没办法用教程的代码继续往下  于是转战VC6.0 比用VS2019简易多了</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji/za-ji-yi/1.png" class="" title="这是我的第一个OpenGL窗口"></div><hr><h3 id="lesson-02"><a href="#lesson-02" class="headerlink" title="lesson 02"></a>lesson 02</h3><ul><li>这节课我创建了第一个（其实是两个）多边形 惭愧的是函数代码我至今还没有记住（so sad）</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji/za-ji-yi/2.png" class="" title="这是我的第一个多边形"></div><hr><h3 id="lesson-03"><a href="#lesson-03" class="headerlink" title="lesson 03"></a>lesson 03</h3><ul><li>开始添加颜色啦 教程里设置的颜色还挺好看的嘿嘿</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji/za-ji-yi/3.png" class="" title="有颜色的多边形"></div><hr><h3 id="lesson-04-amp-lesson-05"><a href="#lesson-04-amp-lesson-05" class="headerlink" title="lesson 04&amp;lesson 05"></a>lesson 04&amp;lesson 05</h3><ul><li>第四课学的是旋转 但我忘记录视频了（哭）</li><li>这一节课终于开始画立体的图形了 我创建了一个金字塔和立方体 除了颜色之外还加入了旋转 这是有意思的开始</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji/za-ji-yi/5.gif" class="" title="这是旋转的立体图形"></div><hr><h3 id="lesson-06"><a href="#lesson-06" class="headerlink" title="lesson 06"></a>lesson 06</h3><ul><li>学会添加纹理啦 终于可以放上自己喜欢的图片了（但其实图片都是朋友给的 选择困难症的我实在是不知道该放哪几张） 我在这里修改了教程的代码 我创建了6个纹理 也就是在立方体的六个面都可以放入图片 虽然花费了很长时间 但最后实现了还是很开心！</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji/za-ji-yi/6.gif" class="" title="放的图片是朋友给的"></div><hr><h3 id="lesson-07-amp-lesson-08"><a href="#lesson-07-amp-lesson-08" class="headerlink" title="lesson 07&amp;lesson 08"></a>lesson 07&amp;lesson 08</h3><ul><li>这两节课是光照和键盘控制以及混合 好复杂 我学的不是很懂 还是要找机会把代码熟练一下 现在真的是太菜了（大哭）</li></ul><hr><h3 id="还有一些想说的"><a href="#还有一些想说的" class="headerlink" title="还有一些想说的"></a>还有一些想说的</h3><ul><li>在这里要感谢Nehe 他多年前的教程对现在的我依旧有很大启发</li><li>总而言之 在OpenGL学习的过程中发现了很多乐趣 但也深刻认识到自己的不足 有时候会自我怀疑是不是真的能学好 我对这些想法的解决办法是 熬呗 哪能咋整</li><li>距离我上一次学习已经过去了十多天了 不知道下一次会是什么时候 我尽力在每一次学习之后总结一下我的感受 以激励不知道何时会到来的下一次</li></ul><hr><h2 id="part2-一些推荐"><a href="#part2-一些推荐" class="headerlink" title="part2 一些推荐"></a>part2 一些推荐</h2><hr><ul><li><h3 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a><strong>电视剧</strong></h3><ul><li>机智的医生生活2——没有人不爱看机医=没有人不需要被治愈 每一集都在笑与泪中度过 没有人会不想成为蔡颂华 建议先看第一季 也非常好看 第二季目前更新到第七集 品质是一如既往 所以不必太担心（写完这一篇我就要去看第七集了 开心嘿嘿</li><li>我在他乡挺好的——致郁与治愈并存 每一集都让人直呼太真实了 目前更新到第十集 如果不烂尾 目测是今年的高分国产剧了</li><li>浪漫医生金师傅——由于上面两部剧更新的实在太慢了 于是我把浪漫医生金师傅又掏出来看了一遍 依旧能感受到巨大的温暖 第二季没有第一季好看我个人认为（<del>第二季男女主真的很不喜欢</del>）（<del>如果找不到资源的话可以联系我</del>）</li></ul></li><li><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a><strong>播客</strong></h3><ul><li>谐星聊天会——我昨天听的是大学寝室奇闻录那一期节目 内容是这几个主讲人分享他们大学寝室里有趣的人和事 这几个人真的很有趣 听的时候我就不断感叹他们的大学生活好精彩 他们的大学同学也好精彩 导致我一个多小时都沉浸在他们的聊天中</li></ul></li></ul><p>​       播客是我最近才发觉的一种很有趣的分享方式 是在豆瓣上看了一个小众圈子的组长的主页 听了一两期节目才被吸引到 由于还没有接触太多所以没办法讲我喜欢的一些播客 但到目前为止 我最大的想法是：<strong>好想做一个自己的播客节目啊</strong> 但目前只是一个想法 具体的实现还没有纳入计划 所以 <strong>有兴趣的朋友请狠狠地戳我</strong> 我们可以一起交流一下 如果能碰撞出不一样的火花 我可能就会开始实践了</p><hr><p>这一篇到这里就要结束了</p><p>现在疫情又严重了 希望大家都能保护好自己</p><p>欢迎志同道合的朋友与我交流</p><p>我们下一篇见</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;part1-OpenGL学习记录&quot;&gt;&lt;a href=&quot;#part1-OpenGL学习记录&quot; class=&quot;headerlink&quot; title=&quot;part1 OpenGL学习记录&quot;&gt;&lt;/a&gt;part1 OpenGL学习记录&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;less</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://lixrangel.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://lixrangel.com/2021/07/31/guan-yu-wo/"/>
    <id>http://lixrangel.com/2021/07/31/guan-yu-wo/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2026-01-13T08:59:15.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>欢迎来到我的世界</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a><strong>关于我</strong></h2><ul><li><p>随时随地在coding的女孩</p></li><li><p>学历：</p><ul><li>本科：南京师范大学 计算机科学与技术专业</li><li>硕士：华东师范大学 计算机科学与技术专业（推免）    </li></ul></li><li><p>能好好活着是我最大的愿望</p></li></ul><hr><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a><strong>爱好</strong></h2><ul><li><p>因为没有什么爱好所以什么都可以是我的爱好</p><ul><li>足球——Hala Madrid！</li><li>追剧——什么都看一点</li><li>coding——努力变得更强中</li></ul></li><li><p>其他的还有待挖掘，欢迎和我交流。</p></li></ul><hr><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a><strong>社交</strong></h2><ul><li><p><strong>微博/QQ/微信</strong>   重度依赖症患者</p></li><li><p><strong>豆瓣/知乎/CSDN</strong>   偶尔使用</p></li><li><p><strong>Instagram/X/Line</strong>    这些真的挺难用的我觉得 但有时候不得不…（你懂的）<del>坏笑</del></p></li></ul><hr><h2 id="信念"><a href="#信念" class="headerlink" title="信念"></a><strong>信念</strong></h2><p><em>经济独立 精神独立 好好活着</em></p><hr><p>本Blog旨在记录一些我自己学习生活过程中的心得体会 所以文章大概都是随心写哈哈哈</p><p>本网站依旧在开发中 如果有任何建议欢迎给我发邮件：<a href="mailto:&#49;&#x31;&#x37;&#x39;&#x34;&#50;&#x36;&#50;&#54;&#x38;&#108;&#x78;&#x72;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#49;&#x31;&#x37;&#x39;&#x34;&#50;&#x36;&#50;&#54;&#x38;&#108;&#x78;&#x72;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a><br>很希望能找到志同道合的朋友一起交流 如果有朋友愿意跟我聊聊的 也欢迎给我发邮件<br>我暂时就想到这么多 未完待续…<br>感谢你的阅读 祝你生活愉快！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;欢迎来到我的世界&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;关于我&quot;&gt;&lt;a href=&quot;#关于我&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
