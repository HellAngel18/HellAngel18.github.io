<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程安全</title>
      <link href="/2025/12/03/xian-cheng-an-quan/"/>
      <url>/2025/12/03/xian-cheng-an-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="Java如何保证多线程安全？"><a href="#Java如何保证多线程安全？" class="headerlink" title="Java如何保证多线程安全？"></a>Java如何保证多线程安全？</h2><ul><li><strong>synchronized关键字</strong>：可以使用synchronized关键字来<font color="#ff0000">同步代码块或方法</font>，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字<font color="#ff0000">锁定对象的监视器</font>来实现的。</li><li><strong>Lock接口和ReentrantLock类</strong>：<code>java.util.concurrent.locks.Lock</code>接口提供了比synchronized更强大的锁机制，ReentrantLock是一个实现该接口的例子，提供了<font color="#ff0000">更灵活的锁管理和更高的性能</font>。</li><li><strong>volatile关键字</strong>：volatile关键字用于变量，确保所有线程<font color="#ff0000">看到的是该变量的最新值</font>，而不是可能存储在本地寄存器的副本。</li><li><strong>原子类</strong>：Java并发库（<code>Java.util.concurrent.atomic</code>）提供了原子类，如AtomicInteger、AtomicLong等，这些类<font color="#ff0000">提供了原子操作</font>，可以用于<font color="#ff0000">更新基本类型的变量</font>而无需额外的同步。</li><li><strong>线程局部变量</strong>：ThreadLocal类可以为<font color="#ff0000">每个线程提供独立的变量副本</font>，这样每个线程拥有自己的变量，消除了竞争条件。</li><li><strong>并发集合</strong>：使用<code>java.util.concurrent</code>包中的<font color="#ff0000">线程安全集合</font>，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。</li></ul><h2 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h2><ul><li><strong>公平锁</strong>：锁被释放之后，<font color="#ff0000">先申请的线程先得到锁</font>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li><strong>非公平锁</strong>：锁被释放之后，<font color="#ff0000">后申请的线程可能会先获取到锁</font>，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul><li><strong>乐观锁</strong>：乐观锁总是假设最好的情况，<font color="#ff0000">认为共享资源每次被访问时不会发生冲突</font>，线程可以不停地执行，无需加锁无需等待，只是<font color="#ff0000">在提交修改的时候去验证对应的数据是否被其他线程修改</font>了。乐观锁通常用于<font color="#ff0000">写比较少的情况</font>，这样可以避免频繁加锁影响性能。乐观锁住要针对的对象是<font color="#ff0000">单个共享变量</font>。CAS是乐观锁的核心思想。</li><li><strong>悲观锁</strong>：总是假设最坏的情况，<font color="#ff0000">认为共享资源每次被访问时都会发生冲突</font>，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源的时候就会阻塞直到锁被上一个持有者释放。悲观锁通常用于<font color="#ff0000">写比较多的情况</font>，这样可以避免频繁失败和重试影响性能。synchronized和ReentrantLock是悲观锁的典型实现。</li></ul><h2 id="CAS（CompareAndSwap，比较再交换）"><a href="#CAS（CompareAndSwap，比较再交换）" class="headerlink" title="CAS（CompareAndSwap，比较再交换）"></a>CAS（CompareAndSwap，比较再交换）</h2><ul><li>体现了一种<font color="#ff0000">乐观锁</font>的思想，在<font color="#ff0000">无锁的状态下保证操作数据的原子性</font>。</li><li>CAS操作包含三个核心的参数：<ul><li>V：要更新的内存地址</li><li>A：预期的旧值</li><li>B：要更新的新值</li></ul></li><li>执行CAS时，当且仅当内存地址V处的值等于预期旧值A时，才会原子地将V处的值改为新值B。如果V处的值不等于A，说明其他线程已经修改了它，此时CAS失败，不做任何操作。</li><li>在java中，CAS底层依赖<code>Unsafe</code>类的方法，调用的是<font color="#ff0000">cpu级别的原子指令</font>。<code>java.util.concurrent.atomic</code>包下的所有原子类都广泛使用了CAS技术。通常配合while(true)循环使用，<font color="#ff0000">失败后不断重试</font>（也就是<font color="#ff0000">自旋</font>）。</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><ul><li>ABA问题是CAS机制的一个漏洞。</li><li>CAS在操作时，只关心“预期值A“和”当前值“是否相等。但<strong>如果一个值从A变成了B，然后又变回了A</strong>，CAS检查时会发现值仍然是A，误认为它没有被修改过，于是执行了交换操作。但在某些业务场景下，A-&gt;B-&gt;A的过程是需要被感知的。</li><li>解决办法：在变量前面追加上版本号或时间戳。JDK1.5之后的<code>AtomicStampedReference</code>类就是用来解决ABA问题的，其中的<code>compareAndSet()</code>方法就是在比较时，<strong>不但会比较当前值，还会比较一个戳记（Stamp）</strong>，这个戳记就相当于版本号，只有当值和版本号都同时满足预期时，CAS才会成功。</li></ul><h2 id="Java有哪些常用的锁？"><a href="#Java有哪些常用的锁？" class="headerlink" title="Java有哪些常用的锁？"></a>Java有哪些常用的锁？</h2><h3 id="从“实现方式”分类"><a href="#从“实现方式”分类" class="headerlink" title="从“实现方式”分类"></a>从“实现方式”分类</h3><p>分为JVM层面的锁和JDK代码层面的锁</p><ul><li>synchronized<ul><li>来源：Java关键字，由JVM也就是Hotspot虚拟机实现。</li><li>特点：<ul><li>加锁和释放锁自动完成</li><li>是可重入锁</li><li>一旦阻塞等待，无法被中断</li><li>默认是非公平锁，不能改成公平</li><li>为了性能优化，JVM内部实现了偏向锁-&gt;轻量级锁-&gt;重量级锁的升级机制。</li></ul></li></ul></li><li>Lock接口及其实现<ul><li>来源：JDK的java.util.concurrent.locks包，基于Java代码（AQS）实现。</li><li>核心实现类：<ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li></ul></li><li>特点：<ul><li>必须调用lock()加锁，必须在finally中调用unlock()释放锁。</li><li>支持尝试获取锁、超时获取、响应中断。</li><li>默认非公平，但是可以构造为公平锁。</li></ul></li></ul></li></ul><h3 id="从“锁的特性”分类"><a href="#从“锁的特性”分类" class="headerlink" title="从“锁的特性”分类"></a>从“锁的特性”分类</h3><ol><li>悲观锁 vs 乐观锁</li><li>可重入锁 vs 不可重入锁</li><li>公平锁 vs 非公平锁</li><li>独占锁 vs 共享锁</li></ol><h2 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h2><h3 id="核心实现机制"><a href="#核心实现机制" class="headerlink" title="核心实现机制"></a>核心实现机制</h3><ul><li>synchronized底层是<strong>基于monitor</strong>来实现的。编译器会在同步的代码块的<strong>开始位置插入<code>monitorenter</code>指令</strong>，在<strong>结束为止插入<code>monitorexit</code>指令</strong>。monitor底层是依赖于操作系统的<font color="#ff0000">Mutex Lock（互斥锁</font>）来实现的。</li></ul><h3 id="monitor的工作原理"><a href="#monitor的工作原理" class="headerlink" title="monitor的工作原理"></a>monitor的工作原理</h3><ul><li>在加锁时，JVM会<strong>修改对象头里的mark work中的数据</strong>，让它指向一个重量级的monitor对象。</li><li>monitor内部有三个属性：<ul><li><strong>owner</strong>：指向当前持有该monitor锁的线程。如果为null，表示锁为被占用。</li><li><strong>entrylist</strong>：一个队列，存放所有处于阻塞状态、等待获取该锁的线程。</li><li><strong>waitset</strong>：一个集合，存放了所有调用了该对象wait()方法而处于等待状态的线程。</li></ul></li></ul><h3 id="锁的获取与释放流程"><a href="#锁的获取与释放流程" class="headerlink" title="锁的获取与释放流程"></a>锁的获取与释放流程</h3><ul><li><strong>抢锁过程</strong>：当一个线程执行到monitorenter指令时，它会尝试获取monitor的所有权，也就是尝试将owner设为自己<ul><li>如果monitor的计数器为0，或者owner本来就是自己，线程会成功拿到锁，并将计数器+1；</li><li>如果锁已经被别人持有了，当前线程就会被阻塞，并进入Entrylist中排队等待。</li></ul></li><li><strong>释放过程</strong>：当执行monitorexit时，monitor的计数器会-1<ul><li>如果减完之后不是0，说明是可重入锁，线程依然持有锁；</li><li>如果减完之后是0，说明锁完全释放，owner被设置为null。此时会从Entrylist中唤醒一个等待的线程来重新竞争锁。</li></ul></li></ul><h2 id="synchronized可重入锁是怎么实现的？"><a href="#synchronized可重入锁是怎么实现的？" class="headerlink" title="synchronized可重入锁是怎么实现的？"></a>synchronized可重入锁是怎么实现的？</h2><ul><li>synchronized底层是利用操作系统Mutex Lock实现的，每一个可重入锁都会关联一个线程ID和一个计数器。</li><li>当一个线程请求获取锁时，会去检查锁的状态：<ul><li>如果计数器为0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换为自己的线程ID。</li><li>如果计数器不为0，代表有线程在访问该对象。此时，如果线程ID是自己的线程ID：<ul><li>可重入锁：将计数器自增1，然后获取到该锁；</li><li>不可重入锁：进入阻塞队列等待。</li></ul></li></ul></li><li>在释放锁时：<ul><li>如果是可重入锁，每一个退出方法，会将计数器减1，直至计数器的值为0，最后释放该锁；</li><li>如果是不可重入锁，线程退出方法，直接就会释放该锁。</li></ul></li></ul><h2 id="synchronized锁升级的过程"><a href="#synchronized锁升级的过程" class="headerlink" title="synchronized锁升级的过程"></a>synchronized锁升级的过程</h2><ul><li>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。整个锁升级的过程，其实就是一个随着竞争加剧，锁的状态逐步升级的过程：从<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li><li>一共三个阶段：<ul><li><strong>偏向锁</strong>：当 JVM 启动 4 秒后（因为有 <code>-XX:BiasedLockingStartupDelay</code> 默认延迟），如果一个对象被创建，它默认是可偏向状态。<ul><li><strong>触发时机</strong>：当<font color="#ff0000">第一个线程访问同步块</font>时。</li><li><strong>核心操作</strong>：JVM不会加锁，而是通过<font color="#ff0000">CAS操作</font>将当前线程的ID记录在对象头的mark word中。</li><li><strong>优势</strong>：当这个线程再次进入同步块时，只需要对比mark word中的线程ID是不是自己。如果是，完全不需要CAS也不需要加锁，直接执行。</li></ul></li><li><strong>轻量级锁</strong>：一旦有第二个线程尝试获取该锁，JVM会撤销偏向锁，将其升级为轻量级锁。<ul><li><strong>触发时机</strong>：<font color="#ff0000">出现了轻微的竞争</font>，或者两个线程交替执行，没有发生同时抢占。</li><li><strong>核心操作</strong>：<ul><li>JVM会在<font color="#ff0000">当前线程的栈帧</font>中建立一个名为<font color="#ff0000">Lock Record</font>（锁记录）的空间。</li><li>然后尝试<font color="#ff0000">用CAS将对象头的mark word替换为指向Lock Record</font>的指针。</li></ul></li><li><strong>自旋</strong>：如果CAS失败，线程不会立刻被挂起，而是会<font color="#ff0000">进行自旋</font>，看看能不能等持有锁的线程把锁释放掉。</li></ul></li><li><strong>重量级锁</strong><ul><li><strong>触发时机</strong>：<ul><li><font color="#ff0000">自旋超过了阈值</font>；</li><li>等待队列里已经有一个线程在自旋了，<font color="#ff0000">又来了第三个线程</font>。</li></ul></li><li><strong>核心操作</strong>：<ul><li>锁标志位变为10，<font color="#ff0000">mark word指向堆中的monitor对象</font>。</li><li>此时，通过CAS抢不到锁的线程，不再自旋，而是直接调用操作系统的底层互斥锁将自己挂起，进入阻塞队列等待唤醒。</li></ul></li></ul></li></ul></li></ul><h2 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h2><ul><li><code>AQS(AbstractQueuedSynchronizer)</code>是抽象队列同步器，是<code>java.util.concurrent</code>包下构建锁和同步器的核心基础框架。</li><li>AQS的核心设计：<ul><li><strong>一个state状态</strong>：<ul><li>是一个<font color="#ff0000">volatile的int类型的变量</font>，代表共享资源的状态；比如在ReentrantLock中，state=0代表锁空闲，state=1代表被占用，state&gt;1代表可重入次数。</li><li>AQS使用<font color="#ff0000">CAS操作来原子地修改这个state值</font>；</li></ul></li><li><strong>CHL变体双向队列</strong>：<ul><li><strong>Node节点</strong>：每个<font color="#ff0000">被阻塞的线程都会被封装成一个Node节点放入队列</font>。Node里包含了线程本身、状态以及前驱和后继指针。</li><li><strong>结构</strong>：队列头通常代表当前持有锁的线程，后续节点则是等待的线程。</li></ul></li></ul></li><li>核心过程：<ul><li><strong>抢锁</strong>：线程进来<font color="#ff0000">先尝试用CAS修改state</font>。如果成功，就拿到了锁，设置当前线程为exclusiveOwnerThread。</li><li><strong>入队与阻塞</strong>：如果CAS失败，线程会被封装成Node加入队尾。加入后，它会检查前驱节点是不是 Head，如果是就有机会再试一次。如果还不行，就调用 <code>LockSupport.park()</code> 让线程进入阻塞状态（此时线程交出 CPU，不再空转）。</li><li><strong>唤醒</strong>：当持有锁的线程调用 release() 时，它会修改 state，并调用 <code>LockSupport.unpark()</code> 唤醒队列中 Head 节点的下一个节点（Next），让其重新尝试 CAS 抢锁。<br><img src="AQS%E7%BB%93%E6%9E%84.png" alt="AQS结构"></li></ul></li></ul><h2 id="ReentrantLock底层原理"><a href="#ReentrantLock底层原理" class="headerlink" title="ReentrantLock底层原理"></a>ReentrantLock底层原理</h2><p><img src="ReentrantLock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="ReentrantLock底层原理"></p><ul><li><code>ReentrantLock</code>里面有一个内部类<code>Sync</code>，<code>Sync</code>继承自AQS，添加锁和释放锁的大部分操作实际上都是在<code>Sync</code>中实现的。<code>Sync</code>有公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>两个子类。</li><li><code>ReentrantLock</code>的底层就是由AQS实现的：<ul><li><strong>状态变量（state）</strong>：AQS内部维护一个<code>volatile int state</code>变量，用于表示锁的计数器或同步状态。<ul><li><font color="#ff0000">state=0</font>：表示锁当前处于未被占用状态；</li><li><font color="#ff0000">state&gt;0</font>：表示锁被占用，state的值即为重入次数。</li></ul></li><li><strong>获取锁（lock()）</strong>：线程尝试使用CAS将state从0设置为1。<ul><li>成功：表示获取锁成功，<font color="#ff0000">将当前线程设置为锁的独占线程</font>，是通过AQS的<code>exclusiveOwnerThread</code>变量记录。</li><li>失败：判断是否是<font color="#ff0000">重入</font>或<font color="#ff0000">阻塞</font>。</li></ul></li><li><strong>锁的重入</strong>：如果发现当前线程就是锁的独占线程，则直接将state+1，实现锁的重入。</li><li><strong>锁的阻塞</strong>：如果获取锁失败，且不是重入，则将<font color="#ff0000">当前线程封装成一个Node节点，加入到AQS的CLH等待队列中</font>，并进入阻塞状态。</li><li>AQS 使用一个<strong>双向链表</strong>作为同步队列（也称 CLH 队列），用于管理所有未能成功获取锁的线程。<ul><li><strong>队列结构：</strong> 队列的头节点（<code>head</code>）表示当前持有锁的线程的 Node，后续节点是等待锁的线程。</li><li><strong>入队：</strong> 竞争失败的线程会被封装成 Node，通过 <strong>CAS 尾插法</strong>安全地加入队列末尾。</li><li><strong>唤醒机制：</strong> 当持有锁的线程释放锁时，会唤醒队列中的<font color="#ff0000">头节点的后继节点</font>，被唤醒的线程会再次尝试竞争锁。</li></ul></li><li>**锁的释放 (<code>unlock()</code>)**：锁的释放过程是递减 <code>state</code> 计数器。<ul><li><strong>递减状态：</strong> 每次调用 <code>unlock()</code>，都将 <code>state</code> 减 1。</li><li><strong>完全释放：</strong> 当 <code>state</code> 递减到 0 时，表示锁被<strong>彻底释放</strong>。</li><li><strong>唤醒后继：</strong> 锁释放后，当前线程会设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>，然后<strong>唤醒 CLH 队列中的下一个等待线程</strong>。</li></ul></li></ul></li></ul><h2 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h2><ul><li><strong>实现层面</strong>：<ul><li><code>synchronized</code>：是Java关键字，<font color="#ff0000">由JVM底层实现</font>。依赖于对象头mark word和操作系统的monitor监视器锁。</li><li><code>ReentrantLock</code>：是JUC包中的一个API类。完全是<font color="#ff0000">用Java实现的</font>，底层依赖AQS。</li></ul></li><li><strong>锁的释放</strong>：<ul><li><code>synchronized</code>：synchronized会<font color="#ff0000">自动加锁和释放锁</font>，当进入synchronized修饰的代码块后会自动加锁，当离开synchronized的代码块后会自动释放锁。</li><li><code>ReentrantLock</code>：<font color="#ff0000">必须手动释放锁</font>。必须在finally块中显式调用unlock()方法。如果忘记释放，将导致灾难性的死锁。</li></ul></li><li>ReentrantLock提供了synchronized不具备的几个高级功能：<ul><li><strong>公平性选择</strong>：<ul><li><code>synchronized</code>是<font color="#ff0000">非公平锁</font>；</li><li><code>ReentrantLock</code>默认为非公平锁，但可以通过构造函数<code>new ReentrantLock(true)</code>创建公平锁。公平锁会按照线程请求的顺序（FIFO）来分配锁，但性能开销更大。</li></ul></li><li><strong>可中断的锁获取：</strong><ul><li><code>synchronized</code> 获取锁是<font color="#ff0000">阻塞且不可中断</font>的。如果一个线程拿不到锁，它会一直死等。</li><li><code>ReentrantLock</code> 提供了 <code>lockInterruptibly()</code> 方法，<font color="#ff0000">允许线程在等待锁的过程中响应中断</font>，增加了灵活性，可以避免死锁。</li></ul></li><li><strong>可超时的锁获取/非阻塞获取：</strong><ul><li><code>synchronized</code> <font color="#ff0000">只能一直等待</font>。</li><li><code>ReentrantLock</code> 提供了 <code>tryLock()</code> 和 <code>tryLock(time, unit)</code> 方法：<ul><li><code>tryLock()</code>：立即尝试获取锁，成功返回 <code>true</code>，失败返回 <code>false</code>，<font color="#ff0000">不阻塞</font>。</li><li><code>tryLock(time, unit)</code>：在指定时间内<font color="#ff0000">可超时地尝试获取锁</font>，超时则放弃。</li></ul></li></ul></li><li><strong>线程等待/唤醒机制：</strong><ul><li><code>synchronized</code>：配合 <code>Object</code> 类的 <code>wait()</code> / <code>notify()</code> / <code>notifyAll()</code> 使用。它只提供一个条件队列，<code>notifyAll</code> 会唤醒所有等待的线程，效率较低。</li><li><code>ReentrantLock</code>：配合 <code>Condition</code> 接口使用。它可以通过 <code>newCondition()</code> 创建多个 <code>Condition</code> 对象，实现更精确的线程分组等待和唤醒，灵活性和效率远高于 <code>wait/notify</code>。</li></ul></li></ul></li></ul><h2 id="指令重排序（单例模式举例）"><a href="#指令重排序（单例模式举例）" class="headerlink" title="指令重排序（单例模式举例）"></a>指令重排序（单例模式举例）</h2><ul><li><p>在JMM的规范下，编译器和cpu为了性能，会进行<font color="#ff0000">指令重排序</font>。重排序在单线程下有<code>as-if-serial</code>语义保证结果正确，但在多线程下，就可能破坏代码的逻辑。比如经典的<strong>双重检查锁定（DCL）下单例模式失效</strong>，就是重排序导致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">//第一次检查，只有为空的时候才加锁 </span></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line"><span class="comment">//类对象加锁 </span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line"><span class="comment">// 第二次检查，为了线程安全</span></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">return</span> uniqueInstance; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uniqueInstance = new Singleton();这段代码其实是分为三步执行：</p><ol><li>为<code>uniqueInstance</code>分配内存空间；</li><li>初始化<code>uniqueInstance</code>；</li><li>将<code>uniqueInstance</code>指向分配的内存地址；</li></ol></li><li><p>但是由于JVM具有指令重排序的特性，执行顺序有可能会变成1-&gt;3-&gt;2。在多线程环境下，线程T1执行了1和3，此时T2调用<code>getUniqueInstance()</code> 后发现<code>uniqueInstance</code>不为空，因此返回<code>uniqueInstance</code>，但此时<code>uniqueInstance</code>还未被初始化。</p></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><strong>保证线程间的可见性</strong>：当一个线程修改了volatile修饰的变量，这个修改<font color="#ff0000">会立刻被强制写回主内存</font>。同时，当其他线程在读取这个变量时，会立即使本地的工作内存失效，<font color="#ff0000">强制从主内存重新读取</font>。这样就确保了所有线程看到的都是最新值。</li><li><strong>禁止进行指令重排序</strong>：用volatile修饰共享变量会在读、写共享变量时加入不同的内存屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果：<ul><li><font color="#245bdb">写-写（Write-Write）屏障</font>：在对volatile变量执行写操作前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</li><li><font color="#245bdb">读-读（Read-Read）屏障</font>：在对volatile变量执行读操作后，会插入一个读屏障。它确保了对volatile变量的读操作后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取的数据是最新的。</li><li><font color="#245bdb">写-读（Write-Read）屏障</font>：发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作都不会被重排序到volatile读之后，同时也确保了volatile读操作之后所有的内存操作都不会被重排序到volatile写之前。</li></ul></li><li>volatile<font color="#ff0000">只保证了可见性和有序性，不保证原子性</font>。比如i++这样的复合操作（也就是只能一个线程写，多个线程读）。</li></ul><h2 id="synchronized和volatile有什么区别？"><a href="#synchronized和volatile有什么区别？" class="headerlink" title="synchronized和volatile有什么区别？"></a>synchronized和volatile有什么区别？</h2><ul><li><strong>使用范围</strong>：<ul><li><code>volatile</code>只能<font color="#ff0000">修饰变量</font>；</li><li><code>synchronized</code>可以<font color="#ff0000">修饰方法或代码块</font>；</li></ul></li><li><strong>保持的特性</strong>：<ul><li><code>volatile</code>只能保证<font color="#ff0000">可见性和有序性</font>；</li><li><code>synchronized</code>可以保证可见性、有序性，还能<font color="#ff0000">保证原子性</font>；</li></ul></li><li><strong>是否阻塞</strong>：<ul><li><code>volatile</code>是<font color="#ff0000">非阻塞的</font>，不会引起线程上下文切换；</li><li><code>synchronized</code>是<font color="#ff0000">阻塞的</font>。如果一个线程获取不到锁，会进入阻塞状态，等待锁被释放，涉及线程上下文的切换。</li></ul></li><li><strong>性能</strong>：<ul><li><code>volatile</code>是<font color="#ff0000">轻量级同步机制</font>，性能开销小；</li><li><code>synchronized</code>是<font color="#ff0000">重量级锁</font>；</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程基础</title>
      <link href="/2025/12/02/xian-cheng-ji-chu/"/>
      <url>/2025/12/02/xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><ul><li><strong>本质区别</strong>：进程是<font color="#ff0000">操作系统资源分配</font>的基本单位，而线程是<font color="#ff0000">任务调度和执行</font>的基本单位。</li><li><strong>在开销方面</strong>：每个进程有<font color="#ff0000">独立的代码和数据空间</font>，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程有自己<font color="#ff0000">独立的运行栈和程序计数器</font>，线程之间切换的开销小。</li><li><strong>稳定性方面</strong>：进程中某个线程崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li><li><strong>内存分配方面</strong>：进程是资源分配的基本单位，拥有独立的地址空间；而线程是cpu调度的基本单位，<font color="#ff0000">几乎不拥有系统资源</font>，只保留少量私有数据（PC、栈、寄存器），主要共享其所属进程的资源。</li></ul><h2 id="进程、线程、协程的区别是什么？"><a href="#进程、线程、协程的区别是什么？" class="headerlink" title="进程、线程、协程的区别是什么？"></a>进程、线程、协程的区别是什么？</h2><ul><li><strong>进程</strong>是操作系统中进行<font color="#ff0000">资源分配和调度的基本单位</font>，拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。<font color="#ff0000">进程间通信需要通过特定的机制</font>，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其<font color="#ff0000">稳定性和安全性相对较高</font>，但同时<font color="#ff0000">上下文切换的开销也大</font>，因为需要保存和恢复整个进程的状态。</li><li><strong>线程</strong>是进程内的一个执行单元，也是<font color="#ff0000">cpu调度和分派的基本单位</font>。与进程不同，线程共享进程的内存空间，包括堆和全局变量。<font color="#ff0000">线程之间通信更加高效</font>，因为它们可以直接读写共享内存。线程的<font color="#ff0000">上下文切换开销较小</font>，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此<font color="#ff0000">存在数据竞争和线程安全</font>的问题，需要通过同步和互斥机制来解决。</li><li><strong>协程</strong>是一种<font color="#ff0000"><strong>用户态</strong>的轻量级线程</font>，其调度完全由用户程序控制，而<font color="#ff0000">不需要内核的参与</font>。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的<font color="#ff0000">切换开销非常小</font>，因为只需要保存和恢复协程的上下文，而<font color="#ff0000">无需进行内核级的上下文切换</font>。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其<font color="#ff0000">编程模型更为复杂</font>。</li></ul><h2 id="线程间的同步方式有哪些？"><a href="#线程间的同步方式有哪些？" class="headerlink" title="线程间的同步方式有哪些？"></a>线程间的同步方式有哪些？</h2><ol><li><strong>互斥锁（Mutex）</strong>：采用<font color="#ff0000">互斥对象机制</font>，只有拥有互斥对象的线程才能访问公共资源。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如<font color="#ff0000">synchronized关键字和各种Lock都是这种机制</font>。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。<font color="#ff0000">读锁不互斥，写锁互斥</font>。大大提高读多写少的共享资源访问效率。</li><li><strong>信号量（Semaphore）</strong>：它允许同一时刻多个线程访问同一资源，但是需要控制<font color="#ff0000">同一时刻访问此资源的最大线程数量</font>。维护一个计数器，线程获取资源时计数器减1，释放时加1。</li><li><strong>屏障（Barrier）</strong>：屏障是一种<font color="#ff0000">同步原语</font>，用于<font color="#ff0000">等待多个线程到达某个点再一起继续执行</font>。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都达到屏障后，它们才会一起执行。</li><li><strong>事件（Event）</strong>：<font color="#ff0000">Wait()/notify()</font>，通过通知操作的方式来保持多线程同步。</li></ol><h2 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h2><ol><li><strong>继承Thread类</strong>：重写<code>run()</code>方法，不能再继承其他父类；</li><li><strong>实现Runnable接口</strong>：重写<code>run()</code>方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其<code>start()</code>方法启动线程；</li><li><strong>实现Callable接口</strong>：重写<code>call()</code>方法，<code>call()</code>方法可以有返回值并且可以抛出异常。将此对象包装进一个<code>FutureTask</code>，然后将<code>FutureTask</code>传入Thread构造器（Thread构造器只接收Runnable参数，而FutureTask实现了Runnable接口）；</li><li><strong>使用线程池创建</strong><h3 id="追问：Runnable和Callable有什么区别？"><a href="#追问：Runnable和Callable有什么区别？" class="headerlink" title="追问：Runnable和Callable有什么区别？"></a>追问：Runnable和Callable有什么区别？</h3></li><li><strong>Runnable接口</strong>run方法<font color="#ff0000">没有返回值</font>。<strong>Callable接口</strong>call方法<font color="#ff0000">有返回值</font>，是个泛型，和Future、FutureTask配合<font color="#ff0000">可以用来获取异步执行的结果</font>。</li><li><strong>Callable接口</strong>的call方法<font color="#ff0000">允许抛出异常</font>；而<strong>Runnable接口</strong>的run方法的<font color="#ff0000">异常只能在内部消化</font>，不能继续上抛。</li></ol><h2 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h2><ul><li><strong>创建状态（new）</strong>：进程<font color="#ff0000">正在被创建</font>，尚未到就绪状态。</li><li><strong>就绪状态（ready）</strong>：进程已处于准备运行状态，即进程<font color="#ff0000">获得了除了处理器之外的一切所需资源</font>，一旦得到处理器资源即可运行。</li><li><strong>运行状态（running）</strong>：进程正在处理器上运行。</li><li><strong>阻塞状态（waiting）</strong>：又称为等待状态，进程正在<font color="#ff0000">等待某一事件而暂停运行</font>如等待某些资源或者等待IO操作完成。即使cpu空闲，该进程也不能运行。</li><li><strong>结束状态（terminated）</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h2 id="线程包含哪些状态？状态之间如何切换？"><a href="#线程包含哪些状态？状态之间如何切换？" class="headerlink" title="线程包含哪些状态？状态之间如何切换？"></a>线程包含哪些状态？状态之间如何切换？</h2><ul><li><strong>新建（NEW）</strong>、<strong>可运行（RUNNABLE）</strong>、<strong>阻塞（BLOCKED）</strong>、<strong>等待(WAITING)<strong>、</strong>计时等待（TIMED_WAITING）</strong>、<strong>终止（TERMINATED）</strong></li><li><font color="#ff0000">创建线程对象</font>是<font color="#ff0000">新建状态</font>，但此时还没有调用start方法；</li><li><font color="#ff0000">调用了start()方法</font>转变为<font color="#ff0000">就绪状态</font>，等待调度。<font color="#ff0000">调度后</font>变为<font color="#ff0000">运行状态</font>；</li><li>线程获取到了cpu的执行权，<font color="#ff0000">执行结束</font>是<font color="#ff0000">终止状态</font>。</li><li>在可运行状态的过程中，如果没有获取cpu的执行权，可能会切换到其他状态：<ul><li>如果<font color="#ff0000">没有获取锁</font>（synchronized或lock）进入<font color="#ff0000">阻塞状态</font>，获得锁再切换为可运行状态；</li><li>如果线程<font color="#ff0000">调用了wait()方法</font>进入<font color="#ff0000">等待状态</font>，其他线程调用notify()唤醒后可切换为可运行状态；</li><li>如果线程<font color="#ff0000">调用了sleep(50)方法</font>，进入<font color="#ff0000">计时等待状态</font>，到时间后可切换为可运行状态。<br><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E5%88%87%E6%8D%A2.png" alt="线程状态及其切换"></li></ul></li></ul><h2 id="进程间通信方式有哪些？"><a href="#进程间通信方式有哪些？" class="headerlink" title="进程间通信方式有哪些？"></a>进程间通信方式有哪些？</h2><ol><li><strong>管道/匿名管道（Pipes）</strong>：用于具有<font color="#ff0000">亲缘关系的父子进程间</font>或者<font color="#ff0000">兄弟进程</font>之间的通信。通信的数据是<font color="#ff0000">无格式的字节流</font>并且<font color="#ff0000">大小受限</font>，<font color="#ff0000">通信的方式是单向的</font>。存在于内存中，进程结束，管道就消失了。</li><li><strong>有名管道（Named Pipes）</strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。有名管道需要在文件系统中创建一个类型为p的设备文件，那么毫无关系的进程就可以<font color="#ff0000">通过这个设备文件进行通信</font>。有名管道严格遵循先进先出。</li><li><strong>消息队列（Message Queuing）</strong>：存放在<font color="#ff0000">内核内存中的消息链表</font>，通过消息队列标识符识别。数据是<font color="#ff0000">有格式、结构化的数据</font>，消息体是用户自定义的数据类型。发送和接收方必须保持数据类型一致。默认遵循先进先出原则，但是也可以<font color="#ff0000">实现消息的随机查询</font>。<font color="#ff0000">生命周期独立于进程</font>，只有在内核重启或显式删除时，消息队列才会被真正删除。每次读写都需要<font color="#ff0000">经过用户态和内核态之间的数据拷贝过程</font>，因此通信速度不是最及时的。</li><li><strong>共享内存（Shared memory）</strong>：使得<font color="#ff0000">多个进程可以访问同一块内存空间</font>，不同进程可以及时看到对方进程中对共享内存中数据的更新。可以<font color="#ff0000">解决</font>消息队列通信中用户态和内核态之间数据<font color="#ff0000">拷贝过程带来的开销</font>。这种方式需要<font color="#ff0000">依靠某种同步操作</font>，如互斥锁和信号量等。但是多进程竞争同个共享资源会造成数据的错乱。</li><li><strong>信号量（Semaphore）</strong>：信号量是一个<font color="#ff0000">计数器</font>，用于多进程对共享数据的访问。这种通信方式主要用于<font color="#ff0000">解决共享内存的问题</font>。</li><li><strong>信号（Signal）</strong>：一种模拟硬件中断的机制，传递的信息量极少，主要<font color="#ff0000">用于通知进程某个事件的发生</font>。</li><li><strong>套接字（Socket）</strong>：此方法主要用于<font color="#ff0000">不同主机之间通过网络进行通信</font>。支持TCP/IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点。</li></ol><h2 id="线程间的通信方式有哪些？"><a href="#线程间的通信方式有哪些？" class="headerlink" title="线程间的通信方式有哪些？"></a>线程间的通信方式有哪些？</h2><ol><li><strong>共享变量</strong><ol><li><strong>volatile关键字</strong>。保证可见性；</li><li><strong>synchronized关键字</strong>。保证可见性和原子性。</li></ol></li><li><strong>等待/通知机制</strong><ol><li>**Object的wait() / notify()**。必须配合synchronized使用。</li><li>**Condition的await() / signal()**。必须配合ReentrantLock使用。</li></ol></li></ol><h2 id="Java中wait和sleep方法的不同？"><a href="#Java中wait和sleep方法的不同？" class="headerlink" title="Java中wait和sleep方法的不同？"></a>Java中wait和sleep方法的不同？</h2><ul><li><strong>方法归属不同</strong>：<ul><li>sleep(long)是<font color="#ff0000">Thread的静态方法</font>，可以在任何地方通过Thread.sleep()调用，无需依赖实例对象。</li><li>wait()、wait(long)都是<font color="#ff0000">Object的成员方法</font>，每个对象都有，<font color="#ff0000">必须通过对象实例来调用</font>。</li></ul></li><li><strong>锁释放的情况</strong>：<ul><li>Thread.sleep()在调用时，线程会暂停执行指定的时间，但是<font color="#ff0000">不会释放持有的对象锁</font>。</li><li>Object.wait()在调用时，线程<font color="#ff0000">会释放持有的对象锁</font>，进入等待状态，直到其他线程调用相同对象的notify()或notifyAll()方法唤醒他。</li></ul></li><li><strong>使用条件</strong>：<ul><li>sleep可以<font color="#ff0000">在任意位置调用</font>，无需事先获得锁。</li><li>wait必须在<font color="#ff0000">同步块或同步方法内调用</font>，即线程需持有该对象的锁，否则抛出异常。</li></ul></li><li><strong>醒来时机不同</strong>：<ul><li>执行sleep(long)和wait(long)的线程都会在<font color="#ff0000">等待相应毫秒后醒来</font></li><li>wait(long)和wait()还<font color="#ff0000">可以被notify唤醒</font>，wait如果<font color="#ff0000">不唤醒就会一直等下去</font>。</li><li>它们都可以被打断唤醒。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2025/10/25/hua-dong-chuang-kou/"/>
      <url>/2025/10/25/hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><img src="%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.svg" alt="无重复字符的最长子串"></p><ul><li>pre存储上一个无重复子串的第一个位置</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><img src="%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.svg" alt="找到字符串中所有字母异位词"></p><ul><li><code>i</code>作为外循环，<code>j</code>每次通过<code>i - n + 1</code>计算</li><li>每次都先更新charS，如果<code>j &lt; 0</code>，continue</li><li>循环结束移除charS中的<code>j</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2025/10/24/shuang-zhi-zhen/"/>
      <url>/2025/10/24/shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a><br><img src="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.svg" alt="盛最多水的容器"></p><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a><br><img src="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.svg" alt="三数之和"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2025/10/23/ha-xi/"/>
      <url>/2025/10/23/ha-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a><br><img src="%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.svg" alt="字母异位词分组"></p><ul><li><code>Map&lt;String, List&lt;String&gt;&gt;</code>存储，key排序后的字符串，value是原始真实的字符串</li><li>返回<code>new ArrayList&lt;&gt;(map.values())</code></li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a><br><img src="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.svg" alt="最长连续序列"></p><ul><li>用一个set存储不重复的nums数组；</li><li>遍历set<ul><li>如果set中存在x-1，说明这不是一个连续子数组的最小值；</li><li>如果不存在，说明这是一个连续子数组的最小值，y=x+1，然后不断循环，如果set中存在，y++；</li><li>循环结束后，更新res</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 8.10安装教程（macOS版）</title>
      <link href="/2025/08/20/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/"/>
      <url>/2025/08/20/elasticsearch-8.10-an-zhuang-jiao-cheng-macos-ban/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从Elasticsearch 8.x开始，官方不再通过Homebrew提供安装包。</p></blockquote><h2 id="1-安装ES"><a href="#1-安装ES" class="headerlink" title="1. 安装ES"></a>1. 安装ES</h2><h3 id="1-1-下载Elasticsearch"><a href="#1-1-下载Elasticsearch" class="headerlink" title="1.1 下载Elasticsearch"></a>1.1 下载Elasticsearch</h3><ul><li>访问<a href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch官方下载页面</a>，选择 8.10.0 版本并下载。</li></ul><h3 id="1-2-解压文件"><a href="#1-2-解压文件" class="headerlink" title="1.2 解压文件"></a>1.2 解压文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf elasticsearch-8.10.0-darwin-x86_64.tar.gz </span><br><span class="line"><span class="built_in">cd</span> elasticsearch-8.10.0</span><br></pre></td></tr></table></figure><h3 id="1-3-启动es"><a href="#1-3-启动es" class="headerlink" title="1.3 启动es"></a>1.3 启动es</h3><ul><li>可以直接进入到 bin 目录，然后执行 <code>./elasticsearch</code> 启动 ES。</li><li>默认情况下，ES 默认是自动配置堆大小的，也就是没有设置固定的内存限制，所以 ES 会根据系统可用内存自动分配，有的时候内存会飙升，可以通过下面的命令运行：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ES_JAVA_OPTS</span>=<span class="string">&quot;-Xms5g -Xmx5g&quot;</span> ./bin/elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p>ES 8.10.0 需要 JDK17 版本</p></blockquote></li></ul><h2 id="2-ES安全功能解除方法"><a href="#2-ES安全功能解除方法" class="headerlink" title="2. ES安全功能解除方法"></a>2. ES安全功能解除方法</h2><ul><li>es的安全功能包括：<ul><li>HTTPS：所有通信默认使用HTTPS。</li><li>身份验证：需要用户名和密码才能访问es。</li><li>证书生成：安装时会自动生成 TLS/SSL 证书。</li></ul></li></ul><h3 id="2-1-方法一：使用HTTPS访问-ES"><a href="#2-1-方法一：使用HTTPS访问-ES" class="headerlink" title="2.1 方法一：使用HTTPS访问 ES"></a>2.1 方法一：使用HTTPS访问 ES</h3><h4 id="2-1-1-找到生成的证书"><a href="#2-1-1-找到生成的证书" class="headerlink" title="2.1.1 找到生成的证书"></a>2.1.1 找到生成的证书</h4><ul><li>CA证书路径：通常位于<code>elasticsearch-8.10.0/config/certs/http_ca.crt</code></li><li>用户名和密码：默认用户是elastic，密码会在启动时生成。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">✅ Elasticsearch security features have been automatically configured!</span><br><span class="line">✅ Authentication is enabled and cluster connections are encrypted.</span><br><span class="line"></span><br><span class="line">ℹ️  Password for the **elastic** user (reset with `bin/elasticsearch-reset-password -u elastic`):</span><br></pre></td></tr></table></figure><blockquote><p>如果忘记了密码，可以通过以下命令重置：<br><code>./bin/elasticsearch-reset-password -u elastic</code></p></blockquote></li></ul><h4 id="2-1-2-使用HTTPS访问"><a href="#2-1-2-使用HTTPS访问" class="headerlink" title="2.1.2 使用HTTPS访问"></a>2.1.2 使用HTTPS访问</h4><ul><li>回到解压目录（不是bin目录），运行以下命令，指定CA证书并使用HTTPS协议：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --cacert config/certs/http_ca.crt -X GET <span class="string">&quot;https://localhost:9201&quot;</span> -u elastic</span><br></pre></td></tr></table></figure><blockquote><p>这里我的9200端口一直显示被占用，所以我换了9201端口。</p></blockquote></li><li>系统会提示输入密码，输入elastic用户的密码后即可访问。</li></ul><h3 id="2-2-访问二：禁用HTTPS和安全功能"><a href="#2-2-访问二：禁用HTTPS和安全功能" class="headerlink" title="2.2 访问二：禁用HTTPS和安全功能"></a>2.2 访问二：禁用HTTPS和安全功能</h3><h4 id="2-2-1-修改配置文件"><a href="#2-2-1-修改配置文件" class="headerlink" title="2.2.1 修改配置文件"></a>2.2.1 修改配置文件</h4><ul><li>编辑 config/elasticsearch.yml 文件，把这两个配置项修改为 false。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span> </span><br><span class="line"><span class="attr">xpack.security.http.ssl.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-2-重启es"><a href="#2-2-2-重启es" class="headerlink" title="2.2.2 重启es"></a>2.2.2 重启es</h4><ul><li>重启es：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-3-使用HTTP访问"><a href="#2-2-3-使用HTTP访问" class="headerlink" title="2.2.3 使用HTTP访问"></a>2.2.3 使用HTTP访问</h4><ul><li>现在可以通过HTTP协议访问es：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="operator">-</span>X <span class="keyword">GET</span> &quot;http://localhost:9201&quot; <span class="operator">-</span>u 用户名:你的密码</span><br></pre></td></tr></table></figure><img src="http%E8%AE%BF%E9%97%AEes.png" alt="http访问es"><blockquote><p>禁用安全功能仅适用于开发环境，生产环境中不建议这样做。<br>如果你在Docker中运行es，请确保将 xpack.security.enabled 设置为 false。</p></blockquote></li></ul><h2 id="3-ES安装IK分词器插件"><a href="#3-ES安装IK分词器插件" class="headerlink" title="3. ES安装IK分词器插件"></a>3. ES安装IK分词器插件</h2><ul><li>IK 分词器是阿里开源的一个中文分词工具，主要用于全文检索和文本分析：<a href="https://github.com/infinilabs/analysis-ik">IK分词器</a></li><li>可以通过命令行直接安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/8.10.0.zip</span><br></pre></td></tr></table></figure></li><li>如果失败的话，使用这个链接下载：<a href="https://release.infinilabs.com/analysis-ik/stable/">IK分词器下载</a><blockquote><p>下载版本必须和es版本相同</p></blockquote></li><li>下载后使用以下命令安装本地插件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install file:YOUR_PATH/elasticsearch-analysis-ik-8.10.0.zip</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器连接hugging face失败</title>
      <link href="/2024/09/16/fu-wu-qi-lian-jie-hugging-face-shi-bai/"/>
      <url>/2024/09/16/fu-wu-qi-lian-jie-hugging-face-shi-bai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-启用hf镜像"><a href="#1-启用hf镜像" class="headerlink" title="1. 启用hf镜像"></a>1. 启用hf镜像</h2><p><code>export HF_ENDPOINT=``https://hf-mirror.com</code></p><h2 id="2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source："><a href="#2-为了防止重启终端后失效，建议将上述命令写入配置文件并执行-source：" class="headerlink" title="2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 source："></a>2. 为了防止重启终端后失效，建议将上述命令写入配置文件并执行 <code>source</code>：</h2><ul><li><code>source ~/.zshrc</code> (如果你使用的是 Zsh)</li><li><code>source ~/.bashrc</code> (如果你使用的是 Bash)</li></ul><h2 id="3-检查是否启用成功"><a href="#3-检查是否启用成功" class="headerlink" title="3. 检查是否启用成功"></a>3. 检查是否启用成功</h2><p>运行以下命令验证环境变量：<br><code>echo $HF_ENDPOINT</code><br>返回下面的说明成功了：<br><img src="hf-mirror%E5%90%AF%E7%94%A8%E6%88%90%E5%8A%9F.png" alt="启用成功"></p><h2 id="4-获取模型克隆命令"><a href="#4-获取模型克隆命令" class="headerlink" title="4. 获取模型克隆命令"></a>4. 获取模型克隆命令</h2><p>打开 Hugging Face 的模型页面，点击 <strong>Clone repository</strong> 获取地址：<br><img src="hugging_face_clone.png" alt="hugging face model"></p><h2 id="5-安装工具并下载"><a href="#5-安装工具并下载" class="headerlink" title="5. 安装工具并下载"></a>5. 安装工具并下载</h2><p>首先安装官方命令行工具 <code>huggingface_hub</code>，然后使用 <code>hf download</code> 即可高速下载：<br><code>pip install -U &quot;huggingface_hub&quot;</code><br><img src="hf_download.png" alt="hf download"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统与环境的安装与搭建</title>
      <link href="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/"/>
      <url>/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近计算机系统基础的实验课安装搭建了Linux系统与环境，整个过程我花费了不短的时间，想在这里简单记录一下，也算是以后学习的一个参考吧。</p><h2 id="一、VMware虚拟机的下载"><a href="#一、VMware虚拟机的下载" class="headerlink" title="一、VMware虚拟机的下载"></a>一、VMware虚拟机的下载</h2><hr><h3 id="进入VM官网"><a href="#进入VM官网" class="headerlink" title="进入VM官网"></a>进入VM官网</h3><p>网址：<strong><a href="http://www.vmware.com/">www.vmware.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/1.png" class="" title="官网页面"></div><hr><h3 id="下载VMware-WorkStation-Pro"><a href="#下载VMware-WorkStation-Pro" class="headerlink" title="下载VMware WorkStation Pro"></a>下载VMware WorkStation Pro</h3><h4 id="①在工作空间中找到Workstation-Pro"><a href="#①在工作空间中找到Workstation-Pro" class="headerlink" title="①在工作空间中找到Workstation Pro"></a>①在工作空间中找到Workstation Pro</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/2.png" class="" title="点击Workstation Pro"></div><h4 id="②选择下载试用版（激活码在后面会给出）"><a href="#②选择下载试用版（激活码在后面会给出）" class="headerlink" title="②选择下载试用版（激活码在后面会给出）"></a>②选择下载试用版（激活码在后面会给出）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/3.png" class="" title="下载试用版"></div><h4 id="③选择for-Windows（这里只以Windows系统为例）"><a href="#③选择for-Windows（这里只以Windows系统为例）" class="headerlink" title="③选择for Windows（这里只以Windows系统为例）"></a>③选择for Windows（这里只以Windows系统为例）</h4><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/4.png" class="" title="选择for Windows"></div><hr><h2 id="二、VMware虚拟机的安装"><a href="#二、VMware虚拟机的安装" class="headerlink" title="二、VMware虚拟机的安装"></a>二、VMware虚拟机的安装</h2><hr><p>点击下一步完成安装即可</p><p>安装完毕后输入许可密钥（以下是网上找的几个密钥，选择哪一个都可以）：</p><p><strong>ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br> YF390-0HF8P-M81RQ-2DXQE-M2UT6<br> ZF71R-DMX85-08DQY-8YMNC-PPHV8</strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.jpg" class="" title="输入密钥"></div><p>到此，VMware的下载安装已完成，接下来完成对Ubuntu的安装。</p><hr><h2 id="三、Ubuntu的下载"><a href="#三、Ubuntu的下载" class="headerlink" title="三、Ubuntu的下载"></a>三、Ubuntu的下载</h2><hr><h3 id="进入Ubuntu官网"><a href="#进入Ubuntu官网" class="headerlink" title="进入Ubuntu官网"></a>进入Ubuntu官网</h3><p>网址：<strong><a href="http://ubuntu.com/">http://ubuntu.com</a></strong></p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/5.png" class="" title="官网页面"></div><hr><h3 id="下载Ubuntu"><a href="#下载Ubuntu" class="headerlink" title="下载Ubuntu"></a>下载Ubuntu</h3><p>点击【Download】</p><p>点击【20.04LTS】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/6.png" class="" title="下载Ubuntu"></div><p><strong>下载位置最好选在一个方便找到的文件夹里，后面会需要该位置</strong></p><hr><h2 id="四、Ubuntu的安装"><a href="#四、Ubuntu的安装" class="headerlink" title="四、Ubuntu的安装"></a>四、Ubuntu的安装</h2><hr><p>打开刚刚安装的VMware，点击【创建新的虚拟机】（Linux将运行在该虚拟机上）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/7.png" class="" title="创建新的虚拟机"></div><p>选择下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/8.png" class="" title="点击下一步"></div><p>选择【稍后安装操作系统】，然后点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/9.png" class="" title="点击下一步"></div><p>选择如下的操作系统和版本</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/10.png" class="" title="选择操作系统和版本"></div><p>选择虚拟机存储位置（最好不要选在系统盘）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/11.png" class="" title="选择虚拟机存储位置"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/12.png" class="" title="点击下一步"></div><p>在自定义硬件中选择合适的内存和处理器，内存给2g足够，根据电脑配置给；处理器默认；网络适配器选择NAT；把不用的打印机移除，否则后面可能会出问题。选择刚才Ubuntu文件的位置。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/13.png" class="" title="点击自定义硬件"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/14.png" class="" title="选择配置"></div><p>设置之后点击【开启虚拟机】</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/15.png" class="" title="开启虚拟机"></div><p><strong>注意：这里可能会显示”此主机支持AMD-V，但AMD-V处于禁用状态“，解决办法为”重启电脑系统，进入BIOS设置，将AMD由【disabled】改为【enabled】“（我的电脑是联想小新air14，不同的电脑可能会有微小差别）</strong></p><p>等待其自行加载Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/16.png" class=""></div><p>选择简体中文并安装Ubuntu</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/17.png" class="" title="安装Ubuntu"></div><p>选择chinese点击继续</p><p>注意：这边可能由于屏幕太小看不到下一步，点不到继续按钮，按住alt+f7，此时鼠标变成小手，可以拖到下面。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/18.png" class=""></div><p>选择正常安装之后点击继续（此处最好把网络断开，不要勾选其他选项）</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/19.png" class=""></div><p>点击安装</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/20.png" class="" title="点击现在安装"></div><p>点击继续进行下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/21.png" class="" title="点击继续"></div><p>地点直接点击继续即可，个人信息填写完毕之后继续点击下一步</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/22.png" class="" title="点击继续"></div><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/23.png" class="" title="点击继续"></div><p>等待ubuntu的自行安装即可，安装完成之后重启虚拟机。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/24.png" class="" title="重新启动"></div><p>点击账号输入密码登录</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/25.png" class="" title="登录"></div><p>安装完成之后发现虚拟机未能全屏显示</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/26.png" class="" title="未全屏显示"></div><p>在左上角的虚拟机一栏中选择安装VMware tools</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/27.png" class="" title="安装VMware tools"></div><p>右键提取到桌面并且解压，将解压文件中的vmware-tools-distrib复制到桌面</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/28.png" class="" title="提取解压"></div><p>右键，在终端打开</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/29.png" class="" title="在终端打开"></div><p>输入以下命令进行安装</p><p><strong>sudo ./vmware-install.pl（注意 . 前面有空格）</strong></p><p>在“Do you still want to proceed with this installation?”后的【no】改为【yes】，即可继续。后面都是直接按确定键即可。</p><p>至此，安装全部完成。</p><div style="width:50%;margin:auto"><img src="/2022/03/19/linux-xi-tong-yu-huan-jing-de-an-zhuang-yu-da-jian/30.png" class="" title="安装完成"></div><hr><p>本篇文章到此就全部结束了</p><p>疫情又严重起来了，大家一定要做好防护啊！</p><p>我们下一篇见！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器显示未连接互联网的解决方法</title>
      <link href="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/"/>
      <url>/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天我一个舍友的浏览器总是显示未连接互联网，试了很多方法都没有解决，于是找到了我这个虽然学计算机但实际上啥也不会的舍友，在度娘的帮助下最后成功解决了。为了下一次遇到同样的问题我可以不再需要询问度娘，我在这里简单记录一下解决方案，同时也算是一个自我提升的过程吧。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><hr><p>请先检查是否真的是网络的问题，比如你的WiFi是否真的连接成功了、你的WiFi是否为可用网络。如果确定不是网络的问题，就可以进入第二步了。</p><hr><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><hr><p>如果确保网络没有问题，接下来请检查是否是浏览器的问题，可以尝试更换浏览器，建议选用Chrome、火狐等浏览器。如果也不是浏览器的问题，就可以进入第三步了。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><hr><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>打开电脑的控制面板</p><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/1.jpg" class="" title="控制面板"></div><hr><h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><ul><li>单击[<strong>网络和Internet</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/7.png" class="" title="单击[网络和Internet]"></div><hr><h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><ul><li>单击[<strong>网络和共享中心</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/2.jpg" class="" title="单击[网络和共享中心]"></div><hr><h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><ul><li>单击左下角[<strong>Internet选项</strong>]</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/3.png" class="" title="单击[Internet选项]"></div><hr><h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><ul><li>选择上方的[<strong>连接</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/4.png" class="" title="选择[连接]"></div><hr><h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><ul><li>单击[<strong>局域网设置</strong>]选项</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/5.png" class="" title="单击[局域网设置]"></div><hr><h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><ul><li>将[<strong>为LAN使用代理服务器</strong>]前的勾选取消</li></ul><div style="width:50%;margin:auto"><img src="/2022/03/06/liu-lan-qi-xian-shi-wei-lian-jie-hu-lian-wang-de-jie-jue-fang-fa/6.jpg" class="" title="取消勾选"></div><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr><p>如果通过上述步骤还是没有解决，可以自行寻求其他解决方案。由于我的技术水平十分有限，可能无法给出更多的解决方法，非常抱歉！</p><hr><p>距离我上一次更新已经过去了四个多月，主要原因还是我太懒了（惭愧），希望之后我能够督促我自己多多记录吧。</p><p>春天来啦，希望大家都能好好生活！</p><p>我们下一篇见！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杂记（二）</title>
      <link href="/2021/10/26/za-ji-er/"/>
      <url>/2021/10/26/za-ji-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h2><hr><p>距离我上一篇文章发布已经过去了三个多月，这三个多月的空余大部分原因是我太懒了，其实在写这篇文章的时候我正在上课，至于是什么课就不说了，万一老师看到了我的网站呢（我瞎说的，怎么可能）。为了督促我自己坚持记录，就在这篇里面随便聊点什么吧（由于老师的声音还不断地进入我的耳朵，所以可能逻辑不是很通顺，还请见谅）</p><ul><li><p>由于南京的疫情，我在两周前才返回校园，还上了两个星期网课，今天是线下课的第二天。也就是说，开学快两个月了，有些老师和同学长什么样我还不知道（so sad）。在我回到学校的那天，其实做了超级大的心理建设，毕竟整整三个月，无法想象那窄小的宿舍会变成什么德行。Fortunately，它并没有发霉，但是还是有一股巨大的潮味，我用了差不多一个星期才缓过来。两个星期过去，生活已经差不多步入了正轨，也是为了再次开启新的生活，我写下了这篇文章。</p></li><li><p>这个学期，我也正式进入了专业学习。由于培养方案的更改，我这学期能修的课少的可怜，还在为之后痛苦的生活嘤嘤嘤。在学习的过程中，我也深刻认识到自己的不足，好像没有太多的精力应付所有的事情，能够把基础打好都已经筋疲力竭了。在平时的生活中，我也有意识地关注一些计算机相关的信息，除了能从中收获一些知识之外，还会产生深深的焦虑，这种焦虑与我学习过程中的困难相互叠加，让我产生了较大的自我怀疑。所以这几天，我一直在尝试消化这种情绪，不知道大家有没有什么比较好的方法，欢迎与我交流，非常感谢！</p></li><li><p>在我写下这篇文章的前两天，南航实验室发生爆炸，使得我这两天的心情也比较沉重。关于这件令人心痛与惋惜的事我不做太多的评价，但是，真诚地希望，所有正在或即将为科研事业奋斗的学生们能够健康平安，在保护好自己的前提下为国家科研事业奉献。</p></li><li><p>最近我开始尝试使用Spotify，最大的体验感受为——歌词界面我好喜欢！对于我这种重度歌词爱好者来说，实在是太完美了吧，我贴个图片。</p></li></ul><div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji-er/1.png" class="" title="搜索界面"></div> <div style="width:50%;margin:auto"><img src="/2021/10/26/za-ji-er/2.png" class="" title="歌词界面"></div><ul><li><p>除此之外，还有我未曾谋面的陌生人给予了我巨大的鼓励，让我对爱与勇气有了更加深刻的思考，在这里也对她们说一声谢谢。</p></li><li><p>之前说的驾考之旅记录有机会的话我也会写一下（毕竟真的太过drama了</p></li></ul><hr><p>秋天也快要过去啦，大家做好保暖措施呀</p><p>我们下一篇见！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记（一）</title>
      <link href="/2021/08/06/za-ji-yi/"/>
      <url>/2021/08/06/za-ji-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="part1-OpenGL学习记录"><a href="#part1-OpenGL学习记录" class="headerlink" title="part1 OpenGL学习记录"></a>part1 OpenGL学习记录</h2><hr><h3 id="lesson-01"><a href="#lesson-01" class="headerlink" title="lesson 01"></a>lesson 01</h3><ul><li>在第一课配置环境这一部分我其实就遇到了困难 开始用VS2019配置 后来发现代码不一样没办法用教程的代码继续往下  于是转战VC6.0 比用VS2019简易多了</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/1.png" class="" title="这是我的第一个OpenGL窗口"></div><hr><h3 id="lesson-02"><a href="#lesson-02" class="headerlink" title="lesson 02"></a>lesson 02</h3><ul><li>这节课我创建了第一个（其实是两个）多边形 惭愧的是函数代码我至今还没有记住（so sad）</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/2.png" class="" title="这是我的第一个多边形"></div><hr><h3 id="lesson-03"><a href="#lesson-03" class="headerlink" title="lesson 03"></a>lesson 03</h3><ul><li>开始添加颜色啦 教程里设置的颜色还挺好看的嘿嘿</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/3.png" class="" title="有颜色的多边形"></div><hr><h3 id="lesson-04-amp-lesson-05"><a href="#lesson-04-amp-lesson-05" class="headerlink" title="lesson 04&amp;lesson 05"></a>lesson 04&amp;lesson 05</h3><ul><li>第四课学的是旋转 但我忘记录视频了（哭）</li><li>这一节课终于开始画立体的图形了 我创建了一个金字塔和立方体 除了颜色之外还加入了旋转 这是有意思的开始</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/5.gif" class="" title="这是旋转的立体图形"></div><hr><h3 id="lesson-06"><a href="#lesson-06" class="headerlink" title="lesson 06"></a>lesson 06</h3><ul><li>学会添加纹理啦 终于可以放上自己喜欢的图片了（但其实图片都是朋友给的 选择困难症的我实在是不知道该放哪几张） 我在这里修改了教程的代码 我创建了6个纹理 也就是在立方体的六个面都可以放入图片 虽然花费了很长时间 但最后实现了还是很开心！</li></ul><div style="width:50%;margin:auto"><img src="/2021/08/06/za-ji-yi/6.gif" class="" title="放的图片是朋友给的"></div><hr><h3 id="lesson-07-amp-lesson-08"><a href="#lesson-07-amp-lesson-08" class="headerlink" title="lesson 07&amp;lesson 08"></a>lesson 07&amp;lesson 08</h3><ul><li>这两节课是光照和键盘控制以及混合 好复杂 我学的不是很懂 还是要找机会把代码熟练一下 现在真的是太菜了（大哭）</li></ul><hr><h3 id="还有一些想说的"><a href="#还有一些想说的" class="headerlink" title="还有一些想说的"></a>还有一些想说的</h3><ul><li>在这里要感谢Nehe 他多年前的教程对现在的我依旧有很大启发</li><li>总而言之 在OpenGL学习的过程中发现了很多乐趣 但也深刻认识到自己的不足 有时候会自我怀疑是不是真的能学好 我对这些想法的解决办法是 熬呗 哪能咋整</li><li>距离我上一次学习已经过去了十多天了 不知道下一次会是什么时候 我尽力在每一次学习之后总结一下我的感受 以激励不知道何时会到来的下一次</li></ul><hr><h2 id="part2-一些推荐"><a href="#part2-一些推荐" class="headerlink" title="part2 一些推荐"></a>part2 一些推荐</h2><hr><ul><li><h3 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a><strong>电视剧</strong></h3><ul><li>机智的医生生活2——没有人不爱看机医=没有人不需要被治愈 每一集都在笑与泪中度过 没有人会不想成为蔡颂华 建议先看第一季 也非常好看 第二季目前更新到第七集 品质是一如既往 所以不必太担心（写完这一篇我就要去看第七集了 开心嘿嘿</li><li>我在他乡挺好的——致郁与治愈并存 每一集都让人直呼太真实了 目前更新到第十集 如果不烂尾 目测是今年的高分国产剧了</li><li>浪漫医生金师傅——由于上面两部剧更新的实在太慢了 于是我把浪漫医生金师傅又掏出来看了一遍 依旧能感受到巨大的温暖 第二季没有第一季好看我个人认为（<del>第二季男女主真的很不喜欢</del>）（<del>如果找不到资源的话可以联系我</del>）</li></ul></li><li><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a><strong>播客</strong></h3><ul><li>谐星聊天会——我昨天听的是大学寝室奇闻录那一期节目 内容是这几个主讲人分享他们大学寝室里有趣的人和事 这几个人真的很有趣 听的时候我就不断感叹他们的大学生活好精彩 他们的大学同学也好精彩 导致我一个多小时都沉浸在他们的聊天中</li></ul></li></ul><p>​       播客是我最近才发觉的一种很有趣的分享方式 是在豆瓣上看了一个小众圈子的组长的主页 听了一两期节目才被吸引到 由于还没有接触太多所以没办法讲我喜欢的一些播客 但到目前为止 我最大的想法是：<strong>好想做一个自己的播客节目啊</strong> 但目前只是一个想法 具体的实现还没有纳入计划 所以 <strong>有兴趣的朋友请狠狠地戳我</strong> 我们可以一起交流一下 如果能碰撞出不一样的火花 我可能就会开始实践了</p><hr><p>这一篇到这里就要结束了</p><p>现在疫情又严重了 希望大家都能保护好自己</p><p>欢迎志同道合的朋友与我交流</p><p>我们下一篇见</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/2021/07/31/guan-yu-wo/"/>
      <url>/2021/07/31/guan-yu-wo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>欢迎来到我的世界</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a><strong>关于我</strong></h2><ul><li><p>随时随地在coding的女孩</p></li><li><p>学历：</p><ul><li>本科：南京师范大学 计算机科学与技术专业</li><li>硕士：华东师范大学 计算机科学与技术专业（推免）    </li></ul></li><li><p>能好好活着是我最大的愿望</p></li></ul><hr><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a><strong>爱好</strong></h2><ul><li><p>因为没有什么爱好所以什么都可以是我的爱好</p><ul><li>足球——Hala Madrid！</li><li>追剧——什么都看一点</li><li>coding——努力变得更强中</li></ul></li><li><p>其他的还有待挖掘，欢迎和我交流。</p></li></ul><hr><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a><strong>社交</strong></h2><ul><li><p><strong>微博/QQ/微信</strong>   重度依赖症患者</p></li><li><p><strong>豆瓣/知乎/CSDN</strong>   偶尔使用</p></li><li><p><strong>Instagram/X/Line</strong>    这些真的挺难用的我觉得 但有时候不得不…（你懂的）<del>坏笑</del></p></li></ul><hr><h2 id="信念"><a href="#信念" class="headerlink" title="信念"></a><strong>信念</strong></h2><p><em>经济独立 精神独立 好好活着</em></p><hr><p>本Blog旨在记录一些我自己学习生活过程中的心得体会 所以文章大概都是随心写哈哈哈</p><p>本网站依旧在开发中 如果有任何建议欢迎给我发邮件：<a href="mailto:&#49;&#x31;&#55;&#x39;&#52;&#x32;&#x36;&#50;&#54;&#56;&#x6c;&#120;&#114;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#49;&#x31;&#55;&#x39;&#52;&#x32;&#x36;&#50;&#54;&#56;&#x6c;&#120;&#114;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a><br>很希望能找到志同道合的朋友一起交流 如果有朋友愿意跟我聊聊的 也欢迎给我发邮件<br>我暂时就想到这么多 未完待续…<br>感谢你的阅读 祝你生活愉快！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
